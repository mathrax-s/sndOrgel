;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PICｵﾙｺﾞｰﾙ演奏+音声再生ver5_7
;ｵﾙｺﾞｰﾙ演奏ﾌﾟﾛｸﾞﾗﾑのｴﾝｼﾞﾝ部分
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;１．機能
;1.ﾊﾟｰﾄ数は3まで演奏可能｡4ﾊﾟｰﾄにするとPIC16FではﾃﾞｰﾀﾒﾓﾘとCPU能力が足りず実装
;　が難しい｡
;・3ﾊﾟｰﾄでの演奏や音声3ch実装時はCPU能力不足のためPWM出力にｱﾝﾀﾞｰﾗﾝが発生する
;　ことがある｡
;・その場合は演奏処理の周期をPWM周期の3倍(96us)､または4倍(128us)とすることで
;　回避できるが､音源の帯域は5KHz､または4KHz以下とする必要がある｡
;2.音源は7ﾋﾞｯﾄPCMの波形ﾃﾞｰﾀで表現し､65kｻﾝﾌﾟﾙまで可能｡但し､ﾀｰｹﾞｯﾄのﾒﾓﾘ構成に依る｡
;・実際に波形を採取し1ｻｲｸﾙ分をﾄﾘﾐﾝｸﾞするとｻﾝﾌﾟﾙ数は整数にはならず小数部の端数
;　を生じる｡
;・そのため計算上のｻﾝﾌﾟﾙ数は整数部16ﾋﾞｯﾄ､小数部8ﾋﾞｯﾄで持ち､ｻﾝﾌﾟﾙのｵﾌｾｯﾄ計算も
;　その精度で行う｡
;3.音高は125Hz〜2KHz(4ｵｸﾀｰﾌﾞ)で､ﾊﾟｰﾄ毎に31種類まで可能｡
;・足りない場合は直指定音符で音符毎に周波数指定が可能｡
;4.音価は32分音符〜全音符で､付点音符と3連符も可能､ﾊﾟｰﾄ毎に7種類､
;・足りない場合は直指定音符で音符毎に音価値指定が可能｡
;5.ﾍﾞﾛｼﾃｨを動的に変更可能｡
;6.ｴﾝﾍﾞﾛｰﾌﾟは7ﾋﾞｯﾄPCMの波形ﾃﾞｰﾀで表現し､256ｻﾝﾌﾟﾙまで可能｡
;・1ｻﾝﾌﾟﾙ当たりの時間を動的に変化させ､ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑを表現する｡
;・ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑを0にとするとﾍﾞﾛｼﾃｨを変化させない｡
;・ｴﾝﾍﾞﾛｰﾌﾟ波形の最後まで進むと最後の状態を保持する｡
;7.ﾃﾝﾎﾟを動的に変更可能｡
;8.ﾋﾟｯﾁﾍﾞﾝﾄﾞは7ﾋﾞｯﾄPCMの波形ﾃﾞｰﾀで表現し､256ｻﾝﾌﾟﾙまで可能｡
;・波形ﾃﾞｰﾀの値は符号付7ﾋﾞｯﾄで表す｡
;・1ｻﾝﾌﾟﾙ当たりの時間を動的に変化させ､ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑを表現する｡
;・ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑを0にとするとﾍﾞﾛｼﾃｨを変化させない｡
;・ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形の最後まで進むと最後の状態を保持する｡
;9.ﾘﾋﾟｰﾄは2系統を設定可能｡
;10.音符ﾃﾞｰﾀは255個/ﾊﾟｰﾄまで可能｡
;11.音声再生を3ch持ち､同時に3音声までの発声が可能｡
;12.音声ﾃﾞｰﾀはﾌﾟﾛｸﾞﾗﾑﾒﾓﾘ､外付けI2CｼﾘｱﾙEEPROM､SDｶｰﾄﾞに置くことができる｡
;・ﾌﾟﾛｸﾞﾗﾑﾒﾓﾘでは7ﾋﾞｯﾄPCMの波形ﾃﾞｰﾀで表現し､最大65kｻﾝﾌﾟﾙ×63音声まで
;　ﾃﾞﾊﾞｲｽのﾘｿｰｽの範囲で実装可能｡
;・外付けI2Cﾒﾓﾘでは8ﾋﾞｯﾄPCMの波形ﾃﾞｰﾀで表現し､最大65kｻﾝﾌﾟﾙ×63音声まで
;　ﾃﾞﾊﾞｲｽのﾘｿｰｽの範囲で実装可能､但し音声は65536ﾊﾞｲﾄ境界を跨らないこと｡
;・外付けI2Cﾒﾓﾘは､I2Cの7ﾋﾞｯﾄｽﾚｰﾌﾞｱﾄﾞﾚｽで最大112ﾁｯﾌﾟまで
;　ﾃﾞﾊﾞｲｽのｱﾄﾞﾚｯｼﾝｸﾞ仕様の範囲で実装可能｡
;・SDﾒﾓﾘｶｰﾄﾞでは8ﾋﾞｯﾄPCMの波形ﾃﾞｰﾀで表現し､最大2Gｻﾝﾌﾟﾙ､63音声まで
;　ﾃﾞﾊﾞｲｽのﾘｿｰｽの範囲で実装可能｡
;13.音声再生のｻﾝﾌﾟﾘﾝｸﾞﾚｰﾄは音声毎に設定可能｡
;
;２．処理方式
;(1)発声処理
;1.ｵﾙｺﾞｰﾙ演奏の各ﾊﾟｰﾄの出力値､および音声再生の出力値の総和を1つのPWMﾎﾟｰﾄに
;　出力する｡
;2.音高2KHzの音源に5次高調波まで含ませると音源の帯域は10KHzとなり､その周期は
;　100usになる｡
;・これをDA変換するにはｻﾝﾌﾟﾘﾝｸﾞ周期は50us以下である必要がある｡
;・実験したところｻﾝﾌﾟﾘﾝｸﾞ周期が80usを超えると音に濁りが目立ってくるので､
;　このくらいが限界と考えられる｡
;3.音声再生は､ｻﾝﾌﾟﾘﾝｸﾞﾚｰﾄが8KHzでは周期は125usになるので､動作ﾀｲﾐﾝｸﾞとしては
;　ｵﾙｺﾞｰﾙ演奏よりは緩やかである｡
;4.PWM周波数は可聴周波数外とするため
;　TMRｸﾛｯｸ=8MHzでPWMｶｳﾝﾄ=256とするとPWM周期は32us、周波数は31KHzになる｡
;5.PWMﾃﾞｭｰﾃｨ設定は8ﾋﾞｯﾄ分解能（CCPRxLのみ)とすることでﾊﾞｯﾌｧﾒﾓﾘを節約する｡
;6.PIC16には乗算命令が無いためｿﾌﾄ処理となり､実際に演算させると11us必要である
;・PWM周期の32usでは複数ﾊﾟｰﾄの処理は不可能なので､演奏処理の周期はPWM周期の
;　2倍の64usとする｡
;7.音声再生の周期はPWM周期の4倍の128usとし､125usとの差は許容誤差と考える｡
;8.音符が進むときはCPU負荷が集中するので､CCPRxLへのﾃﾞｭｰﾃｨ設定ﾃﾞｰﾀをﾊﾞｯﾌｧﾘﾝｸﾞ
;　することでｱﾝﾀﾞｰﾗﾝを防止する｡
;9.ﾀｲ･ｽﾗｰ修飾のときは範囲内の複数音符で1つのｴﾝﾍﾞﾛｰﾌﾟ処理を行い､また音源波形の
;　連続性を維持する｡
;10.ｵﾙｺﾞｰﾙ演奏と音声再生のﾎﾞﾘｭｰﾑ配分を%値で定義する｡
;・乗算回数を少なくするためﾎﾞﾘｭｰﾑ配分は静的に設定する｡
;・ｵﾙｺﾞｰﾙ演奏では､全ﾊﾟｰﾄのﾍﾞﾛｼﾃｨの和が255以下になるように音符ﾃﾞｰﾀを作成し､
;　更にﾎﾞﾘｭｰﾑ配分を反映する｡
;・ｵﾙｺﾞｰﾙ演奏の出力値(PWMﾃﾞｭｰﾃｨ)は以下の流れで決定する｡
;a.ﾍﾞﾛｼﾃｨの指定値(8ﾋﾞｯﾄ)をvel_macﾏｸﾛで音符ﾃﾞｰﾀｿｰｽ中に記述する｡
;b.vel_macﾏｸﾛ内でﾍﾞﾛｼﾃｨ指定値(8ﾋﾞｯﾄ)にPWMｽﾃｯﾌﾟ数(8ﾋﾞｯﾄ)とｵﾙｺﾞｰﾙ演奏のﾎﾞﾘｭｰﾑ
;c.配分値を反映し､音符ﾃﾞｰﾀ(8ﾋﾞｯﾄ)に設定する｡
;d.ｴﾝﾍﾞﾛｰﾌﾟ処理周期でｴﾝﾍﾞﾛｰﾌﾟ波形のPCMﾃﾞｰﾀ(7ﾋﾞｯﾄ)との積(8ﾋﾞｯﾄ)をｴﾝﾍﾞﾛｰﾌﾟ
;　処理後のﾍﾞﾛｼﾃｨ値とする｡
;e.更に音源ﾃﾞｰﾀのPCM値(7ﾋﾞｯﾄ)との積(8ﾋﾞｯﾄ)をﾊﾟｰﾄの出力値とする｡
;　音声再生の出力値は以下の流れで決定する｡
;f.再生処理周期で音声ﾃﾞｰﾀ値(7ﾋﾞｯﾄPCM)をPWMｽﾃｯﾌﾟ数(8ﾋﾞｯﾄ)に変換する｡
;g.音声再生のﾎﾞﾘｭｰﾑ配分値を反映して音声再生chの出力値とする｡
;・ﾋﾟｯﾁﾍﾞﾝﾄﾞは波形ﾃﾞｰﾀの値をｻﾝﾌﾟﾙ飛び数に加減算することでﾋﾟｯﾁを変化させる｡
;　
;(2)ﾀｲﾐﾝｸﾞ設計
;1.音高が2kHzのとき半周期は250usであり､1usを単位として数値化すれば0.4%の精度
;　が確保できる｡
;・音高が125Hzのときは半周期は4000usになり､1us単位では16ﾋﾞｯﾄ長で数値化できる
;2.ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑの範囲を20ms〜5sとすれば､その時間比は250であり8ﾋﾞｯﾄ長で数値化｡
;　できる｡
;・ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀのｻﾝﾌﾟﾙ数を64とすると､ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑが20msのときｻﾝﾌﾟﾙ当たり
;　の時間は312usとなる｡
;・演奏処理の周期(PWM周期×演奏ﾌﾟﾘｽｹｰﾙ値=64us)で約5ｶｳﾝﾄになる｡
;3.ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑの範囲を40ms〜10sとすれば､その時間比は250であり8ﾋﾞｯﾄ長で
;　数値化できる｡
;・ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀのｻﾝﾌﾟﾙ数を128とすると､ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑが40msのときｻﾝﾌﾟﾙ
;　当たりの時間は312usとなる｡
;・演奏処理の周期(PWM周期×演奏ﾌﾟﾘｽｹｰﾙ値=64us)で約5ｶｳﾝﾄになる｡
;4.音符の長さを音価値として数値化するのに､付点音符を表現するには2で割切れる
;　こと､3連符を表現するためには3で割切れることが必要であり､その最小値は6と
;　なる｡
;・8ﾋﾞｯﾄ長で数値化できる音価値の範囲は､32分音符(=6)〜全音符(=192)となる｡
;5.ﾃﾝﾎﾟを100とすれば､音価の最小単位(32分音符の1/6)は12500us､演奏処理の周期
;・PWM周期×演奏ﾌﾟﾘｽｹｰﾙ値=64usでｶｳﾝﾄすると195ｶｳﾝﾄとなる｡
;・ﾃﾝﾎﾟを50〜200に振らせると390〜98ｶｳﾝﾄとなる｡
;・ﾃﾝﾎﾟは演奏中にもﾀﾞｲﾅﾐｯｸに可変とするため､可変値を7ﾋﾞｯﾄの数値にする必要が
;　あり､ﾃﾝﾎﾟﾌﾟﾘｽｹｰﾗを設ける｡
;・音価値までﾌﾙｶｳﾝﾄして次の音符へ進める｡
;6.音価処理周期の管理は全ﾊﾟｰﾄで共通に行うので､共通処理でﾌﾟﾘｽｹｰﾙを行い､
;　ﾌﾙｶｳﾝﾄになったら表示ﾌﾗｸﾞを立てて各ﾊﾟｰﾄ処理へ見せるようにする｡
;
;(3)割込み処理
;1.ｴﾝｼﾞﾝ部の割込み処理はｱﾝﾀﾞｰﾗﾝを発生させないようにCCPRxLを設定するのみとする｡
;2.ｴﾝｼﾞﾝ部の割込み処理でのｺﾝﾃｷｽﾄ保存は必要最小限とする｡
;3.固有の割込みｻｰﾋﾞｽが必要な場合はｴﾝｼﾞﾝ部の割込み処理からｺｰﾙﾊﾞｯｸ関数を呼び出す｡
;4.固有の割込みｻｰﾋﾞｽは､PWM周期割込みとそれ以外の2種類を可能とする｡
;5.PWM周期割込みの固有の割込みｻｰﾋﾞｽはｴﾝｼﾞﾝ部でﾃﾞｭｰﾃｨｻｲｸﾙ値を更新後に呼び出す｡
;　必要があれば､固有の割込み処理でﾃﾞｭｰﾃｨｻｲｸﾙ値を変更することができる｡
;
;(4)曲構成の定義
;1.ｿﾝｸﾞﾃﾞｰﾀの構成をﾃﾝﾌﾟﾚｰﾄ化し､共通のﾘｽﾄ処理でｱｸｾｽできるようにする｡
;2.ｿﾝｸﾞﾃﾞｰﾀへのﾎﾟｲﾝﾀは1曲に付き1ﾗﾍﾞﾙとし､曲名=ｿｰｽｺｰﾄﾞﾌｧｲﾙ名=ﾗﾍﾞﾙ名とする｡
;3.演奏対象のｿﾝｸﾞﾃﾞｰﾀのﾍｯﾀﾞ部をﾚｼﾞｽﾀ領域にｺﾋﾟｰしておくことで､ｿﾝｸﾞﾃﾞｰﾀへの
;　ｱｸｾｽ手順を一律化する｡
;
;(5)ﾒﾓﾘの有効利用
;1.精度を落とせるﾃﾞｰﾀは7ﾋﾞｯﾄを2個ｾｯﾄで1ﾜｰﾄﾞとし､ﾒﾓﾘを節約する｡
;・先行(若ｱﾄﾞﾚｽ)ﾃﾞｰﾀをﾜｰﾄﾞﾃﾞｰﾀの下位に格納する(PIC16のﾘﾄﾙｴﾝﾃﾞｨｱﾝを踏襲)｡
;2.moviw命令により､256境界を跨るﾃｰﾌﾞﾙの検索を可能とし､ﾒﾓﾘ空間を詰めてﾃｰﾌﾞﾙを
;　配置する｡
;3.ｴﾝｼﾞﾝ部分をPage0(0〜0x3ff)に置き､その後にｿﾝｸﾞﾃﾞｰﾀ部分と音声ﾃﾞｰﾀ分部を
;　配置する｡
;4.音声再生のch数､ｵﾙｺﾞｰﾙ演奏のﾊﾟｰﾄ数､ﾋﾟｯﾁﾍﾞﾝﾄﾞ演奏のﾊﾟｰﾄ数は実装数に絞って
;　ﾌﾟﾛｸﾞﾗﾑを展開することで必要なﾒﾓﾘを最小限に抑える｡
;
;(6)ｶｽﾀﾏｲｽﾞを意識したﾌﾟﾛｸﾞﾗﾑ構造
;1.ﾌﾟﾛｸﾞﾗﾑｿｰｽをｴﾝｼﾞﾝ部と固有部に分け､ｴﾝｼﾞﾝ部はﾌﾞﾗｯｸﾎﾞｯｸｽ化し､固有部のｿｰｽｺｰﾄﾞ
;　のみをｶｽﾀﾏｲｽﾞすればよいようにする｡
;2.ｴﾝｼﾞﾝ部の動作を規定する定数は固有部ｿｰｽで宣言する｡
;・この定数のｶｽﾀﾏｲｽﾞはｴﾝｼﾞﾝ部の処理内容を把握した上で行うことが必要｡
;3.割込み処理はﾊｰﾄﾞ依存性があるものの処理内容はｶｽﾀﾏｲｽﾞ対象とはしないため
;　ｴﾝｼﾞﾝ部に配置し､ﾃﾞﾊﾞｲｽの違いによる差異は以下の方法で逃げる｡
;・SFRの呼び名は固有部で別名宣言する｡
;・SFRのﾊﾞﾝｸ設定はbanksel疑似命令を使用する｡
;・処理論理の違いは(今は無いが)条件ｱｾﾝﾌﾞﾙを使う｡
;4.ﾃﾞﾊﾞｲｽやおもちゃに依存する初期設定処理とおもちゃの動作仕様を実現する｡
;　ｺｰﾄﾞはｺｰﾙﾊﾞｯｸ関数として個別部に配置し､ｴﾝｼﾞﾝ部から適宜callする仕組みにする｡
;5.音声ﾃﾞｰﾀと演奏ﾃﾞｰﾀは個別部に配置し､そのｲﾝﾃﾞｯｸｽ部をｴﾝｼﾞﾝ部へﾘﾝｸさせる｡
;6.ｴﾝｼﾞﾝ部の処理状態の把握のため､固有部からｴﾝｼﾞﾝ部の制御表を参照することは
;　可能｡
;
;(7)ﾋﾟﾝ割当てのｶｽﾀﾏｲｽﾞ
;1.PWM出力のﾋﾟﾝ割当ては個別部で宣言/設定することでｿｰｽｺｰﾄﾞの共通化を図る｡
;
;(8)間接ｱﾄﾞﾚｯｼﾝｸﾞの使い方
;1.FSR1は常時ｿﾝｸﾞﾃﾞｰﾀﾍｯﾀﾞをﾎﾟｲﾝﾄしておき､FSR0をﾃﾝﾎﾟﾗﾘに使用する｡
;2.ﾊﾞｲﾄﾃﾞｰﾀﾃｰﾌﾞﾙはFSR0で参照し､ﾜｰﾄﾞﾃﾞｰﾀﾃｰﾌﾞﾙはEEPDATA参照する｡
;
;(9)ﾘﾝｸﾞﾊﾞｯﾌｧのﾎﾟｲﾝﾀの扱い
;1.ﾀｽｸ処理､割込み処理ともにﾎﾟｲﾝﾀはｶﾚﾝﾄﾃﾞｰﾀの次位置を指す｡
;・書込み側であるﾀｽｸ処理は書込み後に書込みﾎﾟｲﾝﾀを進める｡
;・読込み側である割込み処理は読込み後に読込みﾎﾟｲﾝﾀを進める｡
;2.ﾀｽｸ処理は､書込みﾎﾟｲﾝﾀと読込みﾎﾟｲﾝﾀが一致するとき､ﾊﾞｯﾌｧ満杯と認識し
;　ﾃﾞｰﾀの追加を待ち合わせる｡
;3.初期値は書込みﾎﾟｲﾝﾀ､読込みﾎﾟｲﾝﾀは先頭位置､ﾊﾞｯﾌｧ内容は0にして､
;　0のﾃﾞｰﾀで埋まっているようにしておくことで､ﾀｽｸ処理の初期所要時間を担保する｡
;4.割込み処理は､読込みﾎﾟｲﾝﾀを進めてみて書込みﾎﾟｲﾝﾀに追い付く場合は処理を
;　空振りさせる｡
;
;３．ﾀｰｹﾞｯﾄのﾃﾞﾊﾞｲｽ
;1.ﾀｰｹﾞｯﾄのﾃﾞﾊﾞｲｽは下記の条件を満たすPIC12F/16Fの17xx/18xx/19xxとする｡
;・強化命令使用(間接ｱﾄﾞﾚｯｼﾝｸﾞ･相対ｵﾌｾｯﾄ分岐等)
;・強化機能使用(ﾌﾟﾛｸﾞﾗﾑﾒﾓﾘ読込み･ｺﾝﾃｷｽﾄ切替え等)
;・Foscは32MHz以上
;・PWM機能有り
;・EEPROM(I2C)を接続する場合はI2Cﾓｼﾞｭｰﾙ有り
;・SDｶｰﾄﾞを接続する場合はSPIﾓｼﾞｭｰﾙ有り
;・ﾃﾞｰﾀﾒﾓﾘは機能を絞り込んだ場合でも96ﾊﾞｲﾄ以上
;・ﾌﾟﾛｸﾞﾗﾑﾒﾓﾘは機能を絞り込んだ場合でも2Kﾜｰﾄﾞ以上
;
;４．音符ﾃﾞｰﾀのﾌｫｰﾏｯﾄ
;通常の音符は上位3ﾋﾞｯﾄで音価ｺｰﾄﾞ､下位5ﾋﾞｯﾄで音高ｺｰﾄﾞを指す｡
;音高ｺｰﾄﾞ=0は休符を示す｡
;音価ｺｰﾄﾞ=0は下記の特別の意味を持つ｡
;下位5ﾋﾞｯﾄで特別の意味を指す｡
;0:音符ﾃﾞｰﾀの終了
;1:無条件分岐(次のﾊﾞｲﾄで分岐先を指定)
;2:ﾘﾋﾟｰﾄ1回数設定(次のﾊﾞｲﾄで回数を指定)
;3:ﾘﾋﾟｰﾄ1分岐(次のﾊﾞｲﾄで分岐先を指定)
;4:ﾘﾋﾟｰﾄ2回数設定(次のﾊﾞｲﾄで回数を指定)
;5:ﾘﾋﾟｰﾄ2分岐(次のﾊﾞｲﾄで分岐先を指定)
;6:ﾍﾞﾛｼﾃｨ設定(次のﾊﾞｲﾄでﾍﾞﾛｼﾃｨを指定､実際にはvel_macﾏｸﾛで指定する)
;・ﾍﾞﾛｼﾃｨは0〜255で指定する､但し全ﾊﾟｰﾄの合計が255以下であること
;・vel_macﾏｸﾛ内でﾍﾞﾛｼﾃｨに電子ｵﾙｺﾞｰﾙﾎﾞﾘｭｰﾑ配分を反映し､PWMｽﾃｯﾌﾟ数に変換した
;　値が設定される
;7:ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定(次のﾊﾞｲﾄでｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑを指定､実際にはenv_macﾏｸﾛで指定する)
;・ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑはｴﾝﾍﾞﾛｰﾌﾟ波形のｻﾝﾌﾟﾙ時間[us]を指定する｡
;・0のときはｴﾝﾍﾞﾛｰﾌﾟ処理を行わない｡
;8:直指定音符ﾃﾞｰﾀ(次の3ﾊﾞｲﾄで音価と音高を直接指定､実際にはabs_macﾏｸﾛで指定
;　する)
;・音価値を1〜255[32分音符/6]で指定する｡
;・音高値を1〜25000[0.1Hz]で指定する｡
;・音高値はabs_macﾏｸﾛ内で音源ﾃｰﾌﾞﾙ飛び数に変換された値が設定される｡
;9:ﾃﾝﾎﾟ指定(次の1ﾊﾞｲﾄでﾃﾝﾎﾟ増減率[%]を指定)
;10:ﾀｲ･ｽﾗｰ開始(開始〜終了区間を1つのｴﾝﾍﾞﾛｰﾌﾟ表現する)
;11:ﾀｲ･ｽﾗｰ終了
;12:ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定(次のﾊﾞｲﾄでﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑを指定､実際にはpit_macﾏｸﾛで指定
;　する)
;・ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑはﾋﾟｯﾁﾍﾞﾝﾄﾞ波形のｻﾝﾌﾟﾙ時間[us]を指定する｡
;・0のときはﾋﾟｯﾁﾍﾞﾝﾄﾞ処理を行わない｡
;
;５.I2Cﾒﾓﾘのｻﾎﾟｰﾄ
;(1)ｻﾎﾟｰﾄ対象ﾃﾞﾊﾞｲｽ
;・24FC256､24FC512､24FC1025系とする｡
;
;(2)音声ﾃﾞｰﾀの格納
;・実行中のｱｸｾｽを削減するため､I2Cﾒﾓﾘ」には実質の音声ﾃﾞｰﾀのみを置く｡
;・音声ﾃﾞｰﾀのｱﾄﾞﾚｽと長さはﾌｧｰﾑｳｪｱ内に置く｡
;
;(3)処理ﾀｲﾐﾝｸﾞ
;1.I2Cﾒﾓﾘの初期化
;・PIC側の内蔵I2Cﾓｼﾞｭｰﾙの初期化のみで､I2Cﾒﾓﾘ側の初期設定は無い｡
;2.音声再生中のﾃﾞｰﾀ読込み
;・以下の2つの処理から成る｡
;a.I2Cﾒﾓﾘに音声ﾃﾞｰﾀの開始ｱﾄﾞﾚｽを設定する処理であり､音声再生開始時に1回のみ
;　実行する｡実測約60usを要する｡
;b.音声ﾃﾞｰﾀを1ﾊﾞｲﾄずつ受信する｡1ﾊﾞｲﾄ当たり実測約15usを要する｡この内訳は
;　通信時間が13us､CPU実行時間が2usである｡
;・これらの処理は音声ﾃﾞｰﾀのｻﾝﾌﾟﾘﾝｸﾞ周期内に実行完了しなければｱﾝﾀﾞｰﾗﾝが発生する｡
;・a.は処理時間は長いが発生頻度は低く､ｽﾄﾚｰﾄな処理で実装し､出力ﾊﾞｯﾌｧの増設で
;　ｱﾝﾀﾞｰﾗﾝを回避する｡処理時間の60usはPWM周期(32us)の2倍に相当し､出力ﾊﾞｯﾌｧを
;　2ﾃﾞｰﾀ分増設することで対応する｡
;・b.は通信時間を除く実質のCPU時間は実測2usであり､音声のｻﾝﾌﾟﾘﾝｸﾞ周期(125us)に
;　比較して殆ど影響が無い｡この処理は通信待ちが1箇所であるので､その地点で制御を
;　放す処理ﾛｼﾞｯｸで実装する｡具体的には次のﾃﾞｰﾀを要求しておいて制御を放し､次に
;　制御を貰った時にﾃﾞｰﾀを取得するﾛｼﾞｯｸにする｡
;
;６.SDｶｰﾄﾞのｻﾎﾟｰﾄ
;(1)ｻﾎﾟｰﾄ対象ﾃﾞﾊﾞｲｽ
;1.現在は SanDisk256MBminiSD(Ver1) のみ動作確認済みだが､必要に応じてｻﾎﾟｰﾄ
;　対象を広げて行く｡
;2.ﾍﾟｰｼﾞｻｲｽﾞは512ﾊﾞｲﾄとする｡
;
;(2)音声ﾃﾞｰﾀとﾌｧｲﾙｼｽﾃﾑ
;1.音声ﾃﾞｰﾀはﾓﾉﾗﾙ8ﾋﾞｯﾄ8kspsのPCMﾃﾞｰﾀで､WAVﾌｧｲﾙに格納する｡
;2.SDにはFATﾌｧｲﾙｼｽﾃﾑで格納するが､FATﾌｧｲﾙｼｽﾃﾑをﾌｧｰﾑｳｪｱに持ち込むとﾒﾓﾘは
;　嵩張りCPU負荷にもなる｡｡
;3.そこで､｢SDをFATﾌｧｲﾙｼｽﾃﾑでﾌｫｰﾏｯﾄ後にﾌｧｲﾙを順次整然と格納すれば各ﾌｧｲﾙは
;　連続したﾌﾞﾛｯｸに格納される｣と想定して､ﾌｧｰﾑｳｪｱにはPCMﾃﾞｰﾀのSD上のｱﾄﾞﾚｽと
;　長さのみを伝えて､FATﾌｧｲﾙｼｽﾃﾑは意識させないこととする｡
;4.各ﾌｧｲﾙの開始ｱﾄﾞﾚｽとﾌｧｲﾙｻｲｽﾞの情報は､ﾃﾞｨｽｸﾀﾞﾝﾌﾟﾂｰﾙを使って人系で調査する｡
;5.WAVﾌｧｲﾙの先頭と後尾にはWAV形式の制御情報が存在するので､その部分を覗いたPCM
;　ﾃﾞｰﾀの開始ｱﾄﾞﾚｽと長さをﾌｧｰﾑｳｪｱに設定する｡なお､SDへのｱｸｾｽが512ﾊﾞｲﾄ単位である
;　ため､それに合わせてPCMﾃﾞｰﾀの開始ｱﾄﾞﾚｽと長さは512ﾊﾞｲﾄ境界とする｡
;
;(3)処理ﾀｲﾐﾝｸﾞ
;1.SDCの初期化
;・この処理は随所にSDC側での処理待ちがあり､その待ち時間は秒単位にもなる場合
;　があるが､ﾌｧｰﾑｳｪｱの初期化時に1度だけ行う処理なので､ｽﾋﾟﾝﾙｰﾌﾟで待つこととする｡
;2.音声再生中のﾃﾞｰﾀ読込み
;・以下の2つの処理から成る｡
;a.SDCにﾍﾟｰｼﾞの開始ｱﾄﾞﾚｽを設定し､ﾃﾞｰﾀﾄｰｸﾝの開始を待つ｡この処理はﾍﾟｰｼﾞ(512ﾊﾞｲﾄ)
;　毎(125us*512=64ms)に必要な処理であり､実測約600usを要する｡
;b.ﾃﾞｰﾀﾄｰｸﾝの開始後に1ﾊﾞｲﾄずつﾍﾟｰｼﾞｻｲｽﾞ分(512ﾊﾞｲﾄ)のﾃﾞｰﾀを受信する｡1ﾊﾞｲﾄ当たり
;　実測約12usを要する｡この内訳は通信時間が10us､CPU実行時間が2usである｡
;・これらの処理は音声ﾃﾞｰﾀのｻﾝﾌﾟﾘﾝｸﾞ周期内に実行完了しなければｱﾝﾀﾞｰﾗﾝが発生する｡
;・a.は処理時間は長いが発生頻度は低く､処理時間600us/発生周期64msは1%にしか過ぎ
;　ない｡この処理は待ちが随所にあり､ｲﾍﾞﾝﾄﾄﾞﾘﾌﾞﾝで実装するのは複雑になってしまう
;　ため､ｽﾄﾚｰﾄな処理で実装し､出力ﾊﾞｯﾌｧの増設でｱﾝﾀﾞｰﾗﾝを回避する｡処理時間の600us
;　はPWM周期(32us)の19倍に相当し､出力ﾊﾞｯﾌｧを19ﾃﾞｰﾀ分増設することで対応する｡
;・b.は通信時間を除く実質のCPU時間は実測2usであり､音声のｻﾝﾌﾟﾘﾝｸﾞ周期(125us)に
;　比較して殆ど影響が無い｡この処理は通信待ちが1箇所であるので､その地点で制御を
;　放す処理ﾛｼﾞｯｸで実装する｡具体的には次のﾃﾞｰﾀを要求しておいて制御を放し､次に
;　制御を貰った時にﾃﾞｰﾀを取得するﾛｼﾞｯｸにする｡


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｺｰﾙﾊﾞｯｸ関数の要件
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(0)共通仕様
;ﾍﾟｰｼﾞ設定/回復は自動的に行われる｡
;ﾊﾞﾝｸ設定はｺｰﾙﾊﾞｯｸ関数側で行うこと｡戻り時にﾊﾞﾝｸ設定を保障しなくて良い｡
;
;(1)固有の初期設定関数(CB_INIT)
;POR､およびﾘｾｯﾄ後に1度だけ呼び出される｡
;引数無し｡
;固有の初期設定の中では以下の処理を行う｡
;・周辺機能を構成する｡
;・演奏出力ﾎﾟｰﾄを初期化する｡
;・おもちゃ固有の初期化を行う｡
;戻り値無し｡
;
;(2)固有の処理関数(CB_KOYUU)
;定期的(PLAY_OWN_MS[ms]毎)に呼び出される｡
;引数無し｡
;固有の処理の中では以下の処理を行う｡
;・ｵﾙｺﾞｰﾙ演奏の開始､再開始､中断を指示する｡
;・音声再生の開始､再開始､中断を指示する｡
;・LEDやﾓｰﾀｰ制御等のおもちゃ固有の処理を行う｡
;・必要により省電力設定をしてsleepする｡
;・再起動する場合はresetする｡
;戻り値無し｡
;
;(3)演奏終了時の処理(CB_SONG_END)
;曲の演奏が終了した直後に呼び出される｡
;引数無し｡
;｢(2)固有の処理関数(CB_KOYUU)｣と同様の処理を行うことができる｡
;戻り値無し｡
;
;(4)演奏終了時の処理(CB_VOICEn_END)
;nは音声chの番号で0〜2､及びI
;音声再生が終了した直後に呼び出される｡
;引数無し｡
;｢(2)固有の処理関数(CB_KOYUU)｣と同様の処理を行うことができる｡
;戻り値無し｡
;
;(5)割込みｻｰﾋﾞｽの固有処理関数(CB_ISR)
;引数無し｡
;ｴﾝｼﾞﾝ部の割込みｻｰﾋﾞｽﾙｰﾁﾝからPWMﾃﾞｭｰﾃｨｻｲｸﾙの設定後に呼び出される｡
;処理の中では割込み許可/禁止の操作を行わないこと｡
;ﾀﾞｲﾅﾐｯｸｽﾃｯﾌﾟ数は数10ｽﾃｯﾌﾟ以内に抑えること｡
;戻り値無し｡


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｺｰﾙﾊﾞｯｸ関数内で使用可能なｴﾝｼﾞﾝ部のAPI関数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(0)共通仕様
;ﾍﾟｰｼﾞ設定/回復は自動的に行われる｡
;ﾊﾞﾝｸ設定はAPI側で保障される｡
;
;(1)曲選択処理関数(SONG_SEL)
;引数 W:曲番号(0=演奏中断､1〜255=指定曲番号を演奏開始)｡
;戻り値無し｡
;
;(2)音声選択処理関数(VOICEn_SEL)
;nは音声chの番号で0〜2､I､及びS
;引数 W:音声番号(0=再生中断､1〜63=指定音声番号を再生開始)｡
;戻り値無し｡
;
;(3)ﾐｭｰﾄ設定処理関数(MUTE_SET)
;引数 W:ﾐｭｰﾄ設定値
;戻り値無し｡
;
;(4)出力ﾊﾞｯﾌｧのﾃﾞｰﾀ数取得処理関数(BUF_CHK)
;引数無し｡
;戻り値 W:出力ﾊﾞｯﾌｧのﾃﾞｰﾀ数


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾍﾟｰｼﾞ管理の要件
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(1)ﾍﾟｰｼﾞ管理の必要性
;1.度々の機能拡張によりｺｰﾄﾞが増大し､ﾌﾙ機能を実装した場合にはｴﾝｼﾞﾝ部だけでも
;　ﾍﾟｰｼﾞ0(0x800)を超えるようになり､制御移行時にPCLATHの管理が必要になった
;　ﾍﾟｰｼﾞ0を超える部分は256ﾜｰﾄﾞ以下であり､音声PCMからPWM値への変換の部分を
;　ﾍﾟｰｼﾞ1に追い出せば済む｡
;2.実装機能を絞り込んでﾍﾟｰｼﾞ0に収めると､PCLATHの管理は不要であり､少ﾒﾓﾘの
;　ﾃﾞﾊﾞｲｽの場合は余計なｺｰﾄﾞをできるだけ排除したい｡
;3.ｺｰﾄﾞの割り付けに関わるCLATHの管理の要否を自動的に判断して､最小のｺｰﾄﾞを
;　生成することを目指す｡
;
;(2)ﾍﾟｰｼﾞ管理の実装方法
;1.ｺｰﾄﾞを以下の3つの部分に分類して､それぞれの配置先を決める｡
;a.main+音声再生+ｵﾙｺﾞｰﾙ演奏+共通処理の基本機能の部分は､ﾌﾙ機能実装時でも
;　ﾍﾟｰｼﾞ0内に収まるのでﾍﾟｰｼﾞ0の最若番ｱﾄﾞﾚｽに配置する｡
;b.音声PCMからPWM値への変換の部分は､上記1.の直後か､指定のｱﾄﾞﾚｽに
;　配置する｡
;c.固有部のｺｰﾄﾞは､上記2.の直後か､指定のｱﾄﾞﾚｽに配置する｡
;2.制御移行時に移行先のﾍﾟｰｼﾞをPCLATHに設定し､戻り時にPCLATHを戻す｡
;3.制御の移行元先のｺｰﾄﾞの配置ﾍﾟｰｼﾞに依ってpageselﾃﾞｨﾚｸﾃｨﾌﾞの挿入要否を
;　自動的に判断するﾏｸﾛを定義してｿｰｽｺｰﾄﾞのﾎﾟｰﾀﾋﾞﾘﾃｨを担保する｡


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾞﾝｸ管理の要件
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(1)ﾊﾞﾝｸ管理の必要性
;1.度々の機能拡張によりｺｰﾄﾞが増大し､ﾌﾙ機能を実装した場合にはｴﾝｼﾞﾝ部だけでも
;　ﾊﾞﾝｸ0(0x80)を超えるようになり､異なるﾊﾞﾝｸのﾃﾞｰﾀを参照する毎にBSRの設定が
;　必要になった｡
;2.実装機能を絞り込んでﾊﾞﾝｸ0に収めると､BSRの設定は不要である｡
;3.ｺｰﾄﾞの配置先に依ってbankselの挿入要否を自動的に判断するﾏｸﾛを定義して
;　ｿｰｽｺｰﾄﾞのﾎﾟｰﾀﾋﾞﾘﾃｨを担保する｡
;
;(2)ﾊﾞﾝｸ管理の実装方法
;1.ﾃﾞｰﾀを以下の5つの部分に分類して､それぞれの配置先を決める｡
;a.PICのSRAM領域は極めて少ないので細かく管理して詰め込む必要があるので
;　自動的な配置は行わず､配置を人が決めることとする｡
;b.ｴﾝｼﾞﾝ部共通ﾃﾞｰﾀ+ｵﾙｺﾞｰﾙ演奏関連ﾃﾞｰﾀは､ﾌﾙ機能実装時でもﾊﾞﾝｸ0内に収まるので
;　ﾊﾞﾝｸ0の最若番ｱﾄﾞﾚｽに配置する｡
;c.ｴﾝｼﾞﾝ部固有部共用ﾃﾞｰﾀ(ﾊﾞｯﾌｧ出力残数･曲番号･音符ｽﾃｯﾌﾟ･音符ｺｰﾄﾞ･音声番号)は
;　ﾊﾞﾝｸ共通ｱﾄﾞﾚｽに配置する｡
;d.出力ﾊﾞｯﾌｧ+音声再生関連ﾃﾞｰﾀは､その配置先を指定する｡
;e.固有部ﾃﾞｰﾀは､その配置先を指定する｡
;3.実行中のﾓｼﾞｭｰﾙで主に使用するﾊﾞﾝｸが異なるのと､ﾃﾞｰﾀ配置のｶｽﾀﾏｲｽﾞで変化する
;　ため単純にﾊﾞﾝｸ設定/戻しのﾏｸﾛでは解決しない｡
;　そのため､都度bankselﾃﾞｨｸﾃｨﾌﾞを挿入し､ｺｰﾄﾞの効率悪化は必要悪と認識する｡
;4.制御の移行時は､原則として移行先でﾊﾞﾝｸ設定し､移行元でﾊﾞﾝｸを戻す｡


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾎﾟｯﾌﾟﾉｲｽﾞ対策と音声再生中断/音声番号切換えの処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(1)音声再生開始時の対処
;1.現在の出力値から最初の音声出力値までｲﾝｸﾘまたはﾃﾞｸﾘして
;　ﾗﾝﾌﾟ上昇または下降の波形を出力する｡
;2.一致したら､音声再生を開始する｡
;
;(2)音声再生終了時､及びｵﾙｺﾞｰﾙ演奏終了時の対処
;1.最後の出力値をﾃﾞｸﾘしてﾗﾝﾌﾟ下降の波形を出力する｡
;2.0になったら処理を終わる｡
;
;(3)ﾎﾟｯﾌﾟﾉｲｽﾞ対処のﾌﾟﾘｽｹｰﾗ
;1.上記の(1)､(2)の対処はPWM周期をﾌﾟﾘｽｹｰﾙしたﾀｲﾐﾝｸﾞで実行する｡
;2.ﾌﾟﾘｽｹｰﾙ値は音声再生とｵﾙｺﾞｰﾙ演奏で共通とし､固有部で定数宣言する｡
;
;(4)動作状態の管理と処理分担
;1.｢voice?_no｣で音声番号と処理状態を管理する｡
;2.｢voice?_no｣の管理ｺｰﾄﾞは以下とする｡
;・b7-6を処理状態｢sts｣とする｡
;　　11=初期値(ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ)取得中
;　　10=音声再生開始前のﾗﾝﾌﾟ波形出力中
;　　01=再生中断中のﾍﾟｰｼﾞ内の残音声ﾃﾞｰﾀ再生中､
;　　　このとき音声番号は0になっている
;　　00=音声ﾃﾞｰﾀ再生中または再生終了後のﾗﾝﾌﾟ下降中
;・b5〜b0を音声番号｢N｣とする｡
;　　0=音声再生終了
;　　1〜63=再生中の音声番号
;・管理ｺｰﾄﾞの更新はﾒｲﾝﾙｰﾌﾟ側とVOICE?_SELとする｡
;・playback?(音声再生処理関数)では管理ｺｰﾄﾞを参照して処理分岐し､処理結果(ﾃﾞｰﾀの有無)
;　を戻り値として返す｡
;・ﾒｲﾝﾙｰﾌﾟ側でplayback?の戻り値を評価して､ｱﾌﾟﾘｹｰｼｮﾝの進行を制御する｡
;3.sts+Nは下記の順に遷移する｡(通常処理)
;・VOICE?_SELで11+Nとする｡
;・playback?では最初の音声ﾃﾞｰﾀの出力値を取得し､ﾒｲﾝﾙｰﾌﾟで10+Nに更新する｡
;・ﾒｲﾝﾙｰﾌﾟでﾗﾝﾌﾟ波形を出力し､ﾗﾝﾌﾟ波形の出力値が最初の音声ﾃﾞｰﾀの出力値に一致したら､
;　00+Nに更新する｡それまではplayback?を呼び出さない｡
;・音声再生を行う｡
;・playback?が｢ﾃﾞｰﾀ終了｣を返したら､ﾒｲﾝﾙｰﾌﾟは､音声番号が0以外のときはCB_VOICE?_ENDを
;　ｺｰﾙﾊﾞｯｸし､管理ｺｰﾄﾞを00+0にする｡
;・ﾒｲﾝﾙｰﾌﾟでは音声番号が0のときは､出力値をﾗﾝﾌﾟ下降させる｡
;4.音声再生中断/音声番号切換えの制御
;・任意の時点で固有処理部からVOICE?_SELを通して音声再生中断/音声番号切換えが指示され
;　得るが､I2CﾒﾓﾘはACK応答の可否とｽﾄｯﾌﾟｺﾝﾃﾞｨｼｮﾝの実行､SDﾒﾓﾘではﾍﾟｰｼﾞ(512ﾊﾞｲﾄ)境界の
;　ﾀｲﾐﾝｸﾞが必要である｡
;・音声再生の中断/音声番号の切換え､ﾗﾝﾌﾟ波形生成の制御はﾒｲﾝﾙｰﾌﾟとVOICE?_SELで行い､
;　playback?はそれらの制御を意識しないで音声ﾃﾞｰﾀの取得に専念させる｡
;[I2Cﾒﾓﾘ再生中の中断]
;・VOICEI_SELで管理ｺｰﾄﾞを01+0､ﾃﾞｰﾀﾊﾞｲﾄ数を0に設定する｡
;・ﾒｲﾝﾙｰﾌﾟ側では管理ｺｰﾄﾞが01+0のときはplaybackIを呼ぶ｡
;・playbackIでは､残ﾃﾞｰﾀﾊﾞｲﾄ数が0になったため非ACK応答し､｢ﾃﾞｰﾀ終了｣を返す｡
;　ｽﾄｯﾌﾟｺﾝﾃﾞｨｼｮﾝは割愛する(ﾊﾞｽを解放せず､次回はﾘｽﾀｰﾄｺﾝﾃﾞｨｼｮﾝで始める)｡
;・ﾒｲﾝﾙｰﾌﾟ側では音声番号が0のためCB_VOICEI_ENDをｺｰﾙﾊﾞｯｸしないで管理コードを00+0にする｡
;[I2Cﾒﾓﾘ再生中の音声切換え]
;・VOICEI_SELで管理ｺｰﾄﾞを11+0､ﾃﾞｰﾀｱﾄﾞﾚｽとﾃﾞｰﾀ数を設定する｡(通常処理と同じ)
;・playbackIでは､ﾘｽﾀｰﾄｺﾝﾃﾞｨｼｮﾝを実行後ｱﾄﾞﾚｽ設定､最初のﾃﾞｰﾀ取得まで進めて､｢ﾃﾞｰﾀ有り｣を
;　返す｡(通常処理と同じ)
;・以降は通常の音声再生処理が続く｡
;[SDﾒﾓﾘ再生中の中断]
;・VOICES_SELで管理ｺｰﾄﾞを01+0､ﾃﾞｰﾀﾍﾟｰｼﾞ数を0に設定する｡
;・ﾒｲﾝﾙｰﾌﾟ側では管理ｺｰﾄﾞが01+0のときはplaybackSを呼び続ける｡
;・playbackSでは､ﾍﾟｰｼﾞ内の残ﾃﾞｰﾀを読込み中は｢ﾃﾞｰﾀ有り｣を返し､ページ境界になったら
;　残ﾃﾞｰﾀﾍﾟｰｼﾞ数が0であるため｢ﾃﾞｰﾀ終了｣を返す｡
;・ﾒｲﾝﾙｰﾌﾟ側では音声番号が0のためCB_VOICES_ENDをｺｰﾙﾊﾞｯｸしないで管理コードを00+0にする｡
;[SDﾒﾓﾘ再生中の音声切換え]
;・VOICES_SELで管理ｺｰﾄﾞを11+0､ﾃﾞｰﾀｱﾄﾞﾚｽとﾃﾞｰﾀﾍﾟｰｼﾞ数を設定する｡(通常処理と同じ)
;・playbackSでは､ﾍﾟｰｼﾞ内の残ﾃﾞｰﾀを読込み後にﾍﾟｰｼﾞ境界でｱﾄﾞﾚｽ設定が行われ､新ﾍﾟｰｼﾞの
;　再生に切換わる｡このときplaybackSは｢ﾍﾟｰｼﾞ先頭｣を返し､ﾒｲﾝﾙｰﾌﾟ側では｢ﾍﾟｰｼﾞ先頭｣が返る
;　までは前音声番号の再生を継続する｡


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾃﾞﾊﾞｸﾞ情報出力の要件
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(1)ﾃﾞﾊﾞｸﾞ行のﾏｸﾛ定義
;1.ﾃﾞﾊﾞｸﾞ情報取得に掛かるｺｰﾄﾞを少なくし､共通化を図るためﾏｸﾛ定義する
;2.ﾃﾞﾊﾞｸﾞ情報取得の要否を特定の定数宣言で可変とし､ﾏｸﾛ定義で切り分ける
;
;(2)ｱﾌﾟﾘｹｰｼｮﾝとのｲﾝﾀﾌｪｰｽ
;1.BSR保存
;・ﾚｼﾞｽﾀ退避域を少なくするために､BSRの退避回復はせずにﾏｸﾛ内でﾊﾟﾗﾒｰﾀから回復する
;　そのため､ﾊﾟﾗﾒｰﾀで､AP側で必要なﾊﾞﾝｸ番号を正しく指定すること
;・ﾃﾞﾊﾞｸﾞﾙｰﾁﾝ側で必要によりBSRを設定する
;2.ﾍﾟｰｼﾞ設定
;・ﾃﾞﾊﾞｸﾞﾙｰﾁﾝへの制御移行もｱﾌﾟﾘｹｰｼｮﾝと同じく､このﾏｸﾛ内でCALLCNVﾏｸﾛと同等の展開を行う
;3.Wﾚｼﾞｽﾀ保存
;・ﾃﾞﾊﾞｸﾞの有効/無効有無に関わらずAPのｺｰﾄﾞ互換を保つためにWﾚｼﾞｽﾀの保存を行う
;・このﾏｸﾛ内でWﾚｼﾞｽﾀを退避し､ﾃﾞﾊﾞｸﾞﾙｰﾁﾝから復帰後にWﾚｼﾞｽﾀを回復する
;4.ﾃﾞﾊﾞｸﾞ情報のﾃﾞﾊﾞｸﾞﾙｰﾁﾝへの引渡し
;・ﾘﾃﾗﾙ値をﾃﾞﾊﾞｸﾞ情報とする場合は､このﾏｸﾛ内でﾘﾃﾗﾙ値をWﾚｼﾞｽﾀに設定する
;・SFR値をﾃﾞﾊﾞｸﾞ情報とする場合は､このﾏｸﾛ内でSFR値をWﾚｼﾞｽﾀに設定する
;・Wﾚｼﾞｽﾀ値をSFR値をﾃﾞﾊﾞｸﾞ情報とする場合は､Wﾚｼﾞｽﾀをそのまま引渡す



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾍﾟｰｼﾞ間CALLﾏｸﾛ定義
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｴﾝｼﾞﾝ部からvoice7_cnv､voice_cnv､outpt､outpth関数の呼出し
#if CNV_PAGE>=0x800
CALLCNV		macro	label			;共通関数のﾗﾍﾞﾙ
		pagesel	label
		call	label
		pagesel	0
		endm
#else
CALLCNV		macro	label			;共通関数のﾗﾍﾞﾙ
		call	label
		endm
#endif

;ｴﾝｼﾞﾝ部から固有部のｺｰﾙﾊﾞｯｸ関数の呼出し
#if (CNV_PAGE>=0x800)|(KOYUU_PAGE>=0x800)
CALLCB		macro	label			;ｺｰﾙﾊﾞｯｸ関数のﾗﾍﾞﾙ
		pagesel	label
		call	label
		pagesel	0
		endm

#else
CALLCB		macro	label			;ｺｰﾙﾊﾞｯｸ関数のﾗﾍﾞﾙ
		call	label
		endm
#endif

;固有部からｴﾝｼﾞﾝ部API関数の呼出し
#if (CNV_PAGE>=0x800)|(KOYUU_PAGE>=0x800)
CALLAPI		macro	label			;API関数のﾗﾍﾞﾙ
		pagesel	0
		call	label
		pagesel	$
		endm
#else
CALLAPI		macro	label			;API関数のﾗﾍﾞﾙ
		call	label
		endm
#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾎﾟｲﾝﾀﾃｰﾌﾞﾙ生成ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾃｰﾌﾞﾙの先頭ﾗﾍﾞﾙ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ptr_mac		macro	ptr			;ﾎﾟｲﾝﾀ値
		dt	low(ptr)		;ｱﾄﾞﾚｽ(下位)
		dt	high(ptr)		;ｱﾄﾞﾚｽ(上位)
		endm


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;曲ｲﾝﾃﾞｯｸｽ生成ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾃｰﾌﾞﾙの先頭ﾗﾍﾞﾙ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
son_mac		macro	sss,ddd			;曲ﾃﾞｰﾀｱﾄﾞﾚｽ(曲ﾃﾞｰﾀ名),defｷｰﾜｰﾄﾞ
		dt	low(sss)		;ｱﾄﾞﾚｽ(下位)
		dt	high(sss)		;ｱﾄﾞﾚｽ(上位)
#define ddd
		endm
SONG_IDX	equ	2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声ｲﾝﾃﾞｯｸｽ(VOICE_N用)生成ﾏｸﾛ
;　音声再生処理周期のPWM周期に対するﾌﾟﾘｽｹｰﾙ値を生成する
;　音声ﾃﾞｰﾀのｱﾄﾞﾚｽはﾌﾟﾛｸﾞﾗﾑﾌﾗｯｼｭのﾜｰﾄﾞｱﾄﾞﾚｽを指定すること
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
von_mac		macro	aaa,www,sss		;音声ﾃﾞｰﾀのﾜｰﾄﾞｱﾄﾞﾚｽ､ﾜｰﾄﾞ数､ｻﾝﾌﾟﾘﾝｸﾞﾚｰﾄ[sps]
		dt	low(aaa)		;音声ﾃﾞｰﾀのﾜｰﾄﾞｱﾄﾞﾚｽ(下位)
		dt	high(aaa)		;音声ﾃﾞｰﾀのﾜｰﾄﾞｱﾄﾞﾚｽ(上位)
		dt	low(www)		;音声ﾃﾞｰﾀのﾜｰﾄﾞ数(下位)
		dt	high(www)		;音声ﾃﾞｰﾀのﾜｰﾄﾞ数(上位)
		dt	(10000/PWM_PR*1000/sss+5)/10
						;音声再生処理周期のPWM周期に対するﾌﾟﾘｽｹｰﾙ値
		endm
VOICE_N_IDX	equ	5





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音価ﾌﾟﾘｽｹｰﾙ値生成ﾏｸﾛ
;　音価ﾌﾟﾘｽｹｰﾙ値は､音価の基本単位にしている4分音符の1/48の時間を
;　　演奏処理周期をﾍﾞｰｽに作るためのﾌﾟﾘｽｹｰﾙ値
;　　=60*1000000us/TEMPO/48/(PWM_PR*SONG_PS*TEMPO_PS)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ps_mac		macro
		dt	(1000000/TEMPO*100/PWM_PR/SONG_PS/TEMPO_PS/8+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑﾌﾟﾘｽｹｰﾙ値生成ﾏｸﾛ
;　(ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値*ｴﾝﾍﾞﾛｰﾌﾟ波形ｽﾃｯﾌﾟ)当たりの時間を演奏処理周期に対するﾌﾟﾘｽｹｰﾙ値に変換する
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
eps_mac		macro	eee			;ｴﾝﾍﾞﾛｰﾌﾟ処理周期[us/(ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値*ｴﾝﾍﾞﾛｰﾌﾟ波形ｽﾃｯﾌﾟ)]
		dt	(10*eee/PWM_PR/SONG_PS+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑﾌﾟﾘｽｹｰﾙ値生成ﾏｸﾛ
;　(ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値*ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ｽﾃｯﾌﾟ)当たりの時間を演奏処理周期に対するﾌﾟﾘｽｹｰﾙ値に変換する
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pps_mac		macro	ppp			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理周期[us/(ﾋﾟｯﾁﾍﾞﾝﾄﾞ設定値*ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ｽﾃｯﾌﾟ)]
		dt	(10*ppp/PWM_PR/SONG_PS+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音高ﾃｰﾌﾞﾙ(飛び数/演奏処理周期)生成用ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:周波数[0.1Hz]
;　飛び数[1/256]=音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数[1/256]*周波数*演奏処理周期
;　　=ONGEN_S[1/256]/256*(f[0.1Hz]/10*KEYTRNS[%]/100)*(PWM_PR[us]/1000000*SONG_PS)*256
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
on_mac		macro	fff			;音高の周波数[0.1Hz]
		dw	(fff*KEYTRNS/100*ONGEN_S/256*PWM_PR*SONG_PS/100*256/10000+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音価ﾃｰﾌﾞﾙ生成用ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:音価[32分音符/6]
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cho_mac		macro	ccc			;音価値
		dt	ccc
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;無条件分岐ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:分岐先の音符ﾃﾞｰﾀﾃｰﾌﾞﾙｵﾌｾｯﾄ値
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
jmp_mac		macro	jmp			;分岐先
		dt	0x01
		dt	jmp
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾘﾋﾟｰﾄ1回数設定ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾘﾋﾟｰﾄ1回数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rp1_mac		macro	rep1			;ﾘﾋﾟｰﾄ1回数
		dt	0x02
		dt	rep1
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾘﾋﾟｰﾄ1分岐ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾘﾋﾟｰﾄ1分岐先の音符ﾃﾞｰﾀﾃｰﾌﾞﾙｵﾌｾｯﾄ値
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
jp1_mac		macro	jmp1			;ﾘﾋﾟｰﾄ1分岐先
		dt	0x03
		dt	jmp1
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾘﾋﾟｰﾄ2回数設定ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾘﾋﾟｰﾄ2回数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rp2_mac		macro	rep2			;ﾘﾋﾟｰﾄ2回数
		dt	0x04
		dt	rep2
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾘﾋﾟｰﾄ2分岐ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾘﾋﾟｰﾄ2分岐先の音符ﾃﾞｰﾀﾃｰﾌﾞﾙｵﾌｾｯﾄ値
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
jp2_mac		macro	jmp2			;ﾘﾋﾟｰﾄ2分岐先
		dt	0x05
		dt	jmp2
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾍﾞﾛｼﾃｨ設定ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾍﾞﾛｼﾃｨ値(全ﾊﾟｰﾄの合計が255以下になること､0は最小､255は最大)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
vel_mac		macro	vel			;ﾍﾞﾛｼﾃｨ設定値
		dt	0x06
		dt	((PWM_CT-1)*ORGEL_VOL*vel/2550+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
env_mac		macro	ddd			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値
		dt	0x07
		dt	(ddd*1000/TEMPO+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;直指定音符ﾃﾞｰﾀ設定ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ
;　　ccc:音価値([32分音符/6])
;　　fff:音高値(周波数[0.1Hz])
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
abs_mac		macro	ccc,fff			;音価､音高
		dt	0x08
		dt	ccc
		dt	low((fff*KEYTRNS/100*ONGEN_S/256*PWM_PR*SONG_PS/100*256/10000+5)/10)
		dt	high((fff*KEYTRNS/100*ONGEN_S/256*PWM_PR*SONG_PS/100*256/10000+5)/10)
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾃﾝﾎﾟ設定ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾃﾝﾎﾟ変化率[%]
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tmp_mac		macro	ttt			;ﾃﾝﾎﾟ設定値
		dt	0x09
		dt	((100000/TEMPO*100/PWM_PR/SONG_PS/TEMPO_PS/8)*1000/ttt+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾀｲ･ｽﾗｰ開始設定ﾏｸﾛ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tss_mac		macro
		dt	0x0a
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾀｲ･ｽﾗｰ終了設定ﾏｸﾛ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tse_mac		macro
		dt	0x0b
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定ﾏｸﾛ
;　ﾊﾟﾗﾒｰﾀ:ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
pit_mac		macro	ddd			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値
		dt	0x0c
		dt	(ddd*1000/TEMPO+5)/10
		endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;通常音符設定ﾏｸﾛ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
onp_mac		macro	onka,onkou
		dt	onka*32+onkou
		endm





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;演奏ｽﾃｰﾀｽﾋﾞｯﾄ定義
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ONKA_FULL_BIT	equ	7			;音価ﾌﾟﾘｽｹｰﾗ状態ﾋﾞｯﾄ番号
STS_PART0_BIT	equ	0			;ﾊﾟｰﾄ0演奏状態ﾋﾞｯﾄ番号
STS_PART1_BIT	equ	1			;ﾊﾟｰﾄ1演奏状態ﾋﾞｯﾄ番号
STS_PART2_BIT	equ	2			;ﾊﾟｰﾄ2演奏状態ﾋﾞｯﾄ番号
PART_TIE_BIT	equ	0			;ﾊﾟｰﾄ演奏ﾀｲ表示ﾋﾞｯﾄ番号
PART_ON_BIT	equ	1			;ﾊﾟｰﾄ演奏発音表示ﾋﾞｯﾄ番号
VO_STS0_BIT	equ	7			;最初の音声データ取得表示ﾋﾞｯﾄ番号
VO_STS1_BIT	equ	6			;音声再生前のﾗﾝﾌﾟ波形出力表示ﾋﾞｯﾄ番号
VO_STS_MSK	equ	((1<<VO_STS0_BIT)|(1<<VO_STS1_BIT))
						;音声再生制御ﾌﾗｸﾞﾏｽｸ
MUTE_VO0_BIT	equ	0			;ﾐｭｰﾄ表示音声0ﾋﾞｯﾄ番号
MUTE_VO1_BIT	equ	1			;ﾐｭｰﾄ表示音声1ﾋﾞｯﾄ番号
MUTE_VO2_BIT	equ	2			;ﾐｭｰﾄ表示音声2ﾋﾞｯﾄ番号
MUTE_ORGEL_BIT	equ	7			;ﾐｭｰﾄ表示ｵﾙｺﾞｰﾙﾋﾞｯﾄ番号


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;共通ﾃﾞｰﾀ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;共通
	cblock	KYO_BANK			;共通ﾃﾞｰﾀ開始ｱﾄﾞﾚｽ
		out_zan				;出力ﾊﾞｯﾌｧの出力残数
		out_buf_r			;出力ﾊﾞｯﾌｧの読込みﾎﾟｲﾝﾀ
		out_buf_w			;出力ﾊﾞｯﾌｧの書込みﾎﾟｲﾝﾀ
		out_buf:OUT_BUF_N		;出力ﾊﾞｯﾌｧ
		out_buf_end:0			;出力ﾊﾞｯﾌｧの終わり
		koyuu_psL			;固有処理呼出しのﾌﾟﾘｽｹｰﾗ(下位)
		koyuu_psH			;固有処理呼出しのﾌﾟﾘｽｹｰﾗ(上位)
	endc

;ﾃﾞﾊﾞｸﾞ用
#ifdef SHDBG
	cblock
		dbg_h				;16進変換作業域
	endc
#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｴﾝｼﾞﾝ部/固有部共用ﾃﾞｰﾀ(ﾊﾞｯﾌｧ出力残数･曲番号･音符ｽﾃｯﾌﾟ･音符ｺｰﾄﾞ･音声番号)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	CMN_BANK			;ｴﾝｼﾞﾝ部/固有部共用ﾃﾞｰﾀ開始ｱﾄﾞﾚｽ
		mul_a				;乗数1
		mul_b				;乗数2
		mul_cH				;積(上位)
		mul_cL				;積(下位)
		mul_wk				;作業域
		mute_sts			;ﾐｭｰﾄ(出力値を1/2にする)設定状態
						;b7:ｵﾙｺﾞｰﾙ出力ﾐｭｰﾄ(0=しない､1=する)
						;b6:音声chI出力ﾐｭｰﾄ(0=しない､1=する)
						;b5:音声chS出力ﾐｭｰﾄ(0=しない､1=する)
						;b2:音声ch2出力ﾐｭｰﾄ(0=しない､1=する)
						;b1:音声ch1出力ﾐｭｰﾄ(0=しない､1=する)
						;b0:音声ch0出力ﾐｭｰﾄ(0=しない､1=する)
		api_bsr				;APIでのBSR退避域
	endc

#if PART_N>0
;ｵﾙｺﾞｰﾙ共通
	cblock
		song_no				;曲番号(0=演奏終了､1〜255=演奏中の曲番号)
	endc
#endif

#if VOICE_N>0
;音声0個別
	cblock
		voice0_no			;音声番号と制御ﾌﾗｸﾞ
						;　b7-6:制御ﾌﾗｸﾞ
						;　　11=初期値(ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ)取得中
						;　　10=音声再生開始前のﾗﾝﾌﾟ波形出力中
						;　　0x=音声ﾃﾞｰﾀ再生中または再生終了後のﾗﾝﾌﾟ下降中
						;　b5-0:音声番号(0=音声再生終了､1〜63=再生中の音声番号)
	endc
#endif
#if VOICE_N>1
;音声1個別
	cblock
		voice1_no			;音声番号と制御ﾌﾗｸﾞ
						;　b7-6:制御ﾌﾗｸﾞ
						;　　11=初期値(ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ)取得中
						;　　10=音声再生開始前のﾗﾝﾌﾟ波形出力中
						;　　0x=音声ﾃﾞｰﾀ再生中または再生終了後のﾗﾝﾌﾟ下降中
						;　b5-0:音声番号(0=音声再生終了､1〜63=再生中の音声番号)
	endc
#endif
#if VOICE_N>2
;音声2個別
	cblock
		voice2_no			;音声番号と制御ﾌﾗｸﾞ
						;　b7-6:制御ﾌﾗｸﾞ
						;　　11=初期値(ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ)取得中
						;　　10=音声再生開始前のﾗﾝﾌﾟ波形出力中
						;　　0x=音声ﾃﾞｰﾀ再生中または再生終了後のﾗﾝﾌﾟ下降中
						;　b5-0:音声番号(0=音声再生終了､1〜63=再生中の音声番号)
	endc
#endif


;ﾃﾞﾊﾞｸﾞ用
#ifdef SHDBG
	cblock
		dbg_w				;Wﾚｼﾞｽﾀ退避域(共通ﾊﾞﾝｸに配置)
		dbg_b				;BSR退避域(共通ﾊﾞﾝｸに配置)
		dbg_d				;ﾃﾞﾊﾞｸﾞ情報退避域
	endc
#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#if PART_N>0
	cblock	ORGEL_BANK			;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀ開始ｱﾄﾞﾚｽ
;ﾊﾟｰﾄ共通
		part_su				;実装ﾊﾟｰﾄ数
		song_ps				;演奏ﾌﾟﾘｽｹｰﾗ
		song_sts			;演奏状態
						;　b7:音価ﾌﾟﾘｽｹｰﾗ状態(0=空､1=満)
						;　b2:ﾊﾟｰﾄ2演奏状態(0=演奏終了､1=演奏中)
						;　b1:ﾊﾟｰﾄ1演奏状態(0=演奏終了､1=演奏中)
						;　b0:ﾊﾟｰﾄ0演奏状態(0=演奏終了､1=演奏中)
		onka_psn			;音価ﾌﾟﾘｽｹｰﾙ値
		onka_ps				;音価ﾌﾟﾘｽｹｰﾗ
		tempo_ps			;ﾃﾝﾎﾟﾌﾟﾘｽｹｰﾗ
		song_out			;演奏出力値
		song_pop_ps			;演奏終了ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗ
;ﾊﾟｰﾄ0個別
		part0_step			;音符ｽﾃｯﾌﾟ
		part0_onpu			;音符ｺｰﾄﾞ
		part0_sts			;演奏状態
						;b1:休符/発音音符(0=休符､1=発音音符)
						;b0:ﾀｲ･ｽﾗｰ設定(0=無､1=有)
		part0_onka_zan			;音価ｶｳﾝﾄ残
		part0_repeat			;ﾘﾋﾟｰﾄｶｳﾝﾀ
						;　b7-4:ｶｳﾝﾀ2
						;　b3-0:ｶｳﾝﾀ1
		part0_ongen_nF			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(1/256桁)
		part0_ongen_nL			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(下位)
		part0_ongen_nH			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(上位)
		part0_ongen_tobiF		;音源波形ｻﾝﾌﾟﾙ飛び数(1/256単位)
		part0_ongen_tobiL		;音源波形ｻﾝﾌﾟﾙ飛び数(下位)
		part0_ongen_ofF			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(1/256単位)
		part0_ongen_ofL			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(下位)
		part0_ongen_ofH			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(上位)
		part0_velo			;ﾍﾞﾛｼﾃｨ設定値
		part0_velo_enve			;ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値
		part0_enve			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値
		part0_enve_ps			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑﾌﾟﾘｽｹｰﾗ(ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ値に対応)
		part0_enve_pss			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑﾌﾟﾘｽｹｰﾗ(音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ値に対応)
		part0_enve_n			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		part0_enve_of			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀﾜｰﾄﾞｵﾌｾｯﾄ
		part0_enve_h			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀ上位7ﾋﾞｯﾄ
	endc
#if PITCH_N>0
	cblock
		part0_pitch			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値
		part0_pitch_ps			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑﾌﾟﾘｽｹｰﾗ(ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ値に対応)
		part0_pitch_pss			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑﾌﾟﾘｽｹｰﾗ(音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ値に対応)
		part0_pitch_n			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		part0_pitch_of			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀﾜｰﾄﾞｵﾌｾｯﾄ
		part0_pitch_h			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀ上位7ﾋﾞｯﾄ
	endc
#endif
#endif

#if PART_N>1
;ﾊﾟｰﾄ1個別
	cblock
		part1_step			;音符ｽﾃｯﾌﾟ
		part1_onpu			;音符ｺｰﾄﾞ
		part1_sts			;演奏状態
						;b1:休符/発音音符(0=休符､1=発音音符)
						;b0:ﾀｲ･ｽﾗｰ設定(0=無､1=有)
		part1_onka_zan			;音価ｶｳﾝﾄ残
		part1_repeat			;ﾘﾋﾟｰﾄｶｳﾝﾀ
						;　b7-4:ｶｳﾝﾀ2
						;　b3-0:ｶｳﾝﾀ1
		part1_ongen_nF			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(1/256桁)
		part1_ongen_nL			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(下位)
		part1_ongen_nH			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(上位)
		part1_ongen_tobiF		;音源波形ｻﾝﾌﾟﾙ飛び数(1/256単位)
		part1_ongen_tobiL		;音源波形ｻﾝﾌﾟﾙ飛び数(下位)
		part1_ongen_ofF			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(1/256単位)
		part1_ongen_ofL			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(下位)
		part1_ongen_ofH			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(上位)
		part1_velo			;ﾍﾞﾛｼﾃｨ設定値
		part1_velo_enve			;ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値
		part1_enve			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値
		part1_enve_ps			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑﾌﾟﾘｽｹｰﾗ(ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ値に対応)
		part1_enve_pss			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑﾌﾟﾘｽｹｰﾗ(音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ値に対応)
		part1_enve_n			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		part1_enve_of			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀﾜｰﾄﾞｵﾌｾｯﾄ
		part1_enve_h			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀ上位7ﾋﾞｯﾄ
	endc
#if PITCH_N>1
	cblock
		part1_pitch			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値
		part1_pitch_ps			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑﾌﾟﾘｽｹｰﾗ(ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ値に対応)
		part1_pitch_pss			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑﾌﾟﾘｽｹｰﾗ(音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ値に対応)
		part1_pitch_n			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		part1_pitch_of			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀﾜｰﾄﾞｵﾌｾｯﾄ
		part1_pitch_h			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀ上位7ﾋﾞｯﾄ
	endc
#endif
#endif

#if PART_N>2
;ﾊﾟｰﾄ2個別
	cblock
		part2_step			;音符ｽﾃｯﾌﾟ
		part2_onpu			;音符ｺｰﾄﾞ
		part2_sts			;演奏状態
						;b1:休符/発音音符(0=休符､1=発音音符)
						;b0:ﾀｲ･ｽﾗｰ設定(0=無､1=有)
		part2_onka_zan			;音価ｶｳﾝﾄ残
		part2_repeat			;ﾘﾋﾟｰﾄｶｳﾝﾀ
						;　b7-4:ｶｳﾝﾀ2
						;　b3-0:ｶｳﾝﾀ1
		part2_ongen_nF			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(1/256桁)
		part2_ongen_nL			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(下位)
		part2_ongen_nH			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(上位)
		part2_ongen_tobiF		;音源波形ｻﾝﾌﾟﾙ飛び数(1/256単位)
		part2_ongen_tobiL		;音源波形ｻﾝﾌﾟﾙ飛び数(下位)
		part2_ongen_ofF			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(1/256単位)
		part2_ongen_ofL			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(下位)
		part2_ongen_ofH			;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙｵﾌｾｯﾄ(上位)
		part2_velo			;ﾍﾞﾛｼﾃｨ設定値
		part2_velo_enve			;ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値
		part2_enve			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値
		part2_enve_ps			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑﾌﾟﾘｽｹｰﾗ(ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ値に対応)
		part2_enve_pss			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑﾌﾟﾘｽｹｰﾗ(音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ値に対応)
		part2_enve_n			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		part2_enve_of			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀﾜｰﾄﾞｵﾌｾｯﾄ
		part2_enve_h			;ｴﾝﾍﾞﾛ-ﾌﾟ波形ﾃﾞｰﾀ上位7ﾋﾞｯﾄ
	endc
#if PITCH_N>2
	cblock
		part2_pitch			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値
		part2_pitch_ps			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑﾌﾟﾘｽｹｰﾗ(ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ値に対応)
		part2_pitch_pss			;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑﾌﾟﾘｽｹｰﾗ(音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ値に対応)
		part2_pitch_n			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		part2_pitch_of			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀﾜｰﾄﾞｵﾌｾｯﾄ
		part2_pitch_h			;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀ上位7ﾋﾞｯﾄ
	endc
#endif
#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声再生ﾃﾞｰﾀ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;#if (VOICE_N+VOICE_I+VOICE_S)>0
;;音声再生共通
;	cblock	VOICE_BANK			;音声再生ﾃﾞｰﾀ開始ｱﾄﾞﾚｽ
;		voice_pop_ps			;音声再生ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹ
;						;　b6:0=音声I再生終了､1=再生中
;						;　b5:0=音声S再生終了､1=再生中
;						;　b2:0=音声2再生終了､1=再生中
;						;　b1:0=音声1再生終了､1=再生中
;						;　b0:0=音声0再生終了､1=再生中
;		voice_out			;音声出力値
;	endc
;#endif

#if VOICE_N>0
;音声0個別
	cblock
		voice0_ptL			;音声ﾃﾞｰﾀﾊﾞｲﾄﾎﾟｲﾝﾀ(下位)
		voice0_ptH			;音声ﾃﾞｰﾀﾊﾞｲﾄﾎﾟｲﾝﾀ(上位)
		voice0_zanL			;音声ﾃﾞｰﾀ残数(下位)
		voice0_zanH			;音声ﾃﾞｰﾀ残数(上位)
		voice0_data			;音声ﾃﾞｰﾀ(一時保管)
		voice0_psn			;音声再生ﾌﾟﾘｽｹｰﾙ値
		voice0_ps			;音声再生ﾌﾟﾘｽｹｰﾗ
		voice0_out			;音声出力値
		voice0_pop			;音声ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ
	endc
#endif

#if VOICE_N>1
;音声1個別
	cblock
		voice1_ptL			;音声ﾃﾞｰﾀﾊﾞｲﾄﾎﾟｲﾝﾀ(下位)
		voice1_ptH			;音声ﾃﾞｰﾀﾊﾞｲﾄﾎﾟｲﾝﾀ(上位)
		voice1_zanL			;音声ﾃﾞｰﾀ残数(下位)
		voice1_zanH			;音声ﾃﾞｰﾀ残数(上位)
		voice1_data			;音声ﾃﾞｰﾀ(一時保管)
		voice1_psn			;音声再生ﾌﾟﾘｽｹｰﾙ値
		voice1_ps			;音声再生ﾌﾟﾘｽｹｰﾗ
		voice1_out			;音声出力値
		voice1_pop			;音声ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ
	endc
#endif

#if VOICE_N>2
;音声2個別
	cblock
		voice2_ptL			;音声ﾃﾞｰﾀﾊﾞｲﾄﾎﾟｲﾝﾀ(下位)
		voice2_ptH			;音声ﾃﾞｰﾀﾊﾞｲﾄﾎﾟｲﾝﾀ(上位)
		voice2_zanL			;音声ﾃﾞｰﾀ残数(下位)
		voice2_zanH			;音声ﾃﾞｰﾀ残数(上位)
		voice2_data			;音声ﾃﾞｰﾀ(一時保管)
		voice2_psn			;音声再生ﾌﾟﾘｽｹｰﾙ値
		voice2_ps			;音声再生ﾌﾟﾘｽｹｰﾗ
		voice2_out			;音声出力値
		voice2_pop			;音声ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ
	endc
#endif

;#if VOICE_I>0
;;音声I2C個別
;	cblock
;		mmi2c_slv			;ﾌﾗｯｼｭﾒﾓﾘのｽﾚｰﾌﾞｱﾄﾞﾚｽ(ｺﾝﾄﾛｰﾙｺｰﾄﾞ､Rﾋﾞｯﾄ付き)
;		mmi2c_ad_h			;ﾌﾗｯｼｭﾒﾓﾘのｱﾄﾞﾚｽ上位ﾊﾞｲﾄ
;		mmi2c_ad_l			;ﾌﾗｯｼｭﾒﾓﾘのｱﾄﾞﾚｽ下位ﾊﾞｲﾄ
;		mmi2c_len_h			;ﾌﾗｯｼｭﾒﾓﾘの長さ上位ﾊﾞｲﾄ
;		mmi2c_len_l			;ﾌﾗｯｼｭﾒﾓﾘの長さ下位ﾊﾞｲﾄ
;		voiceI_psn			;音声再生ﾌﾟﾘｽｹｰﾙ値
;		voiceI_ps			;音声再生ﾌﾟﾘｽｹｰﾗ
;		voiceI_out			;音声出力値
;		voiceI_pop			;音声ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ
;	endc
;#endif
;
;#if VOICE_S>0
;;音声SD個別
;	cblock
;		mmsd_ad0			;SDｶｰﾄﾞのﾍﾟｰｼﾞｱﾄﾞﾚｽ0(MSB)
;		mmsd_ad1			;SDｶｰﾄﾞのﾍﾟｰｼﾞｱﾄﾞﾚｽ1
;		mmsd_ad2			;SDｶｰﾄﾞのﾍﾟｰｼﾞｱﾄﾞﾚｽ2(LSB)b0は常に0
;		mmsd_len0			;SDｶｰﾄﾞのﾍﾟｰｼﾞ数0(MSB)
;		mmsd_len1			;SDｶｰﾄﾞのﾍﾟｰｼﾞ数1
;		mmsd_len2			;SDｶｰﾄﾞのﾍﾟｰｼﾞ数2(LSB)
;		mmsd_rct			;SDﾘﾄﾗｲｶｳﾝﾀ
;		mmsd_res			;SDﾚｽﾎﾟﾝｽ
;		mmsd_bct_h			;SDｶｰﾄﾞﾍﾟｰｼﾞのﾊﾞｲﾄ数ｶｳﾝﾀ上位ﾊﾞｲﾄ
;		mmsd_bct_l			;SDｶｰﾄﾞﾍﾟｰｼﾞのﾊﾞｲﾄ数ｶｳﾝﾀ下位ﾊﾞｲﾄ
;		voiceS_psn			;音声再生ﾌﾟﾘｽｹｰﾙ値
;		voiceS_ps			;音声再生ﾌﾟﾘｽｹｰﾗ
;		voiceS_out			;音声出力値
;		voiceS_pop			;音声ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ
;	endc
;#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾎﾟｲﾝﾀの枠組み
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	0
		PTR_L				;ﾎﾟｲﾝﾀ(下位)
		PTR_H				;ﾎﾟｲﾝﾀ(上位)
	endc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;波形ﾃﾞｰﾀ(音源)の枠組み
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	0
		WAVE_N_F			;波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(1/256桁)
		WAVE_N_L			;波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(下位)
		WAVE_N_H			;波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数(上位)
		WAVE_DATA			;波形ﾃﾞｰﾀ(7ﾋﾞｯﾄPCM×2､下位=先行､上位=後行)
	endc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;波形ﾃﾞｰﾀ(ｴﾝﾍﾞﾛｰﾌﾟ､ﾋﾟｯﾁﾍﾞﾝﾄﾞ)の枠組み
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	0
		ENVE_N				;波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		ENVE_DATA			;波形ﾃﾞｰﾀ(7ﾋﾞｯﾄPCM×2､下位=先行､上位=後行)
	endc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾎﾞｲｽﾃﾞｰﾀｲﾝﾃﾞｯｸｽ部(音声n)の枠組み
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	0
		HDR_VOn_PT_L			;音声ﾃﾞｰﾀﾜｰﾄﾞｱﾄﾞﾚｽ(下位)
		HDR_VOn_PT_H			;音声ﾃﾞｰﾀﾜｰﾄﾞｱﾄﾞﾚｽ(上位)
		HDR_VOn_LN_L			;音声ﾃﾞｰﾀﾜｰﾄﾞ数(下位)
		HDR_VOn_LN_H			;音声ﾃﾞｰﾀﾜｰﾄﾞ数(上位)
		HDR_VOn_PSN			;音声ﾃﾞｰﾀ再生ﾌﾟﾘｽｹｰﾙ値
		HDR_VOn_size:0
	endc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾎﾞｲｽﾃﾞｰﾀｲﾝﾃﾞｯｸｽ部(音声I)の枠組み
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	0
		HDR_VOI_PT_L			;音声ﾃﾞｰﾀﾊﾞｲﾄｱﾄﾞﾚｽ(下位)
		HDR_VOI_PT_H			;音声ﾃﾞｰﾀﾊﾞｲﾄｱﾄﾞﾚｽ(上位)
		HDR_VOI_LN_L			;音声ﾃﾞｰﾀﾊﾞｲﾄ数(下位)
		HDR_VOI_LN_H			;音声ﾃﾞｰﾀﾊﾞｲﾄ数(上位)
		HDR_VOI_PSN			;音声ﾃﾞｰﾀ再生ﾌﾟﾘｽｹｰﾙ値
		HDR_VOI_PT_C			;音声ﾃﾞｰﾀﾁｯﾌﾟ番号
		HDR_VOI_size:0
	endc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾎﾞｲｽﾃﾞｰﾀｲﾝﾃﾞｯｸｽ部(音声S)の枠組み
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	0
		HDR_VOS_AD0			;音声ﾃﾞｰﾀｱﾄﾞﾚｽ0(b31-24)
		HDR_VOS_AD1			;音声ﾃﾞｰﾀｱﾄﾞﾚｽ1(b23-16)
		HDR_VOS_AD2			;音声ﾃﾞｰﾀｱﾄﾞﾚｽ2(b15-8)
		HDR_VOS_LEN0			;音声ﾃﾞｰﾀﾍﾟｰｼﾞ数0(b23-16)
		HDR_VOS_LEN1			;音声ﾃﾞｰﾀﾍﾟｰｼﾞ数1(b15-8)
		HDR_VOS_LEN2			;音声ﾃﾞｰﾀﾍﾟｰｼﾞ数2(b7-0)
		HDR_VOS_PSN			;音声ﾃﾞｰﾀ再生ﾌﾟﾘｽｹｰﾙ値
		HDR_VOS_size:0
	endc


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｿﾝｸﾞﾃﾞｰﾀﾍｯﾀﾞ部の枠組み
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cblock	0
;ﾊﾟｰﾄ共通
		HDR_ONKA_PS			;音価処理ﾌﾟﾘｽｹｰﾙ値
		HDR_PART_SU			;実装ﾊﾟｰﾄ数
;ﾊﾟｰﾄ0個別
		HDR_PART0_ONPU_L		;音符ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART0_ONPU_H		;音符ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART0_ONKOU_L		;音高ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART0_ONKOU_H		;音高ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART0_ONKA_L		;音価ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART0_ONKA_H		;音価ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART0_ONGEN_L		;音源ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART0_ONGEN_H		;音源ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART0_ENVE_PS		;ｴﾝﾍﾞﾛｰﾌﾟ処理ﾌﾟﾘｽｹｰﾙ値
		HDR_PART0_ENVE_L		;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART0_ENVE_H		;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
	endc
#if PITCH_N>0
	cblock
		HDR_PART0_PITCH_PS		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理ﾌﾟﾘｽｹｰﾙ値
		HDR_PART0_PITCH_L		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART0_PITCH_H		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
	endc
#endif
	cblock
;ﾊﾟｰﾄ1個別
		HDR_PART1_ONPU_L		;音符ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART1_ONPU_H		;音符ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART1_ONKOU_L		;音高ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART1_ONKOU_H		;音高ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART1_ONKA_L		;音価ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART1_ONKA_H		;音価ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART1_ONGEN_L		;音源ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART1_ONGEN_H		;音源ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART1_ENVE_PS		;ｴﾝﾍﾞﾛｰﾌﾟ処理ﾌﾟﾘｽｹｰﾙ値
		HDR_PART1_ENVE_L		;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART1_ENVE_H		;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
	endc
#if PITCH_N>1
	cblock
		HDR_PART1_PITCH_PS		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理ﾌﾟﾘｽｹｰﾙ値
		HDR_PART1_PITCH_L		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART1_PITCH_H		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
	endc
#endif
	cblock
;ﾊﾟｰﾄ2個別
		HDR_PART2_ONPU_L		;音符ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART2_ONPU_H		;音符ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART2_ONKOU_L		;音高ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART2_ONKOU_H		;音高ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART2_ONKA_L		;音価ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART2_ONKA_H		;音価ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART2_ONGEN_L		;音源ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART2_ONGEN_H		;音源ﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
		HDR_PART2_ENVE_PS		;ｴﾝﾍﾞﾛｰﾌﾟ処理ﾌﾟﾘｽｹｰﾙ値
		HDR_PART2_ENVE_L		;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART2_ENVE_H		;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
	endc
#if PITCH_N>2
	cblock
		HDR_PART2_PITCH_PS		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理ﾌﾟﾘｽｹｰﾙ値
		HDR_PART2_PITCH_L		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(下位)
		HDR_PART2_PITCH_H		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾃｰﾌﾞﾙﾎﾟｲﾝﾀ(上位)
	endc
#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾍﾞｸﾀﾃｰﾌﾞﾙ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		org	0			;ﾘｾｯﾄ時はここから
		goto	main			;ｵﾙｺﾞｰﾙｴﾝｼﾞﾝを起動


		org	4			;割り込み処理はここから
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;割込み処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PWM周期割込み処理
		banksel	PIRxPWM			;BANK設定
		btfss	PIRxPWM,PIRxPWMf	;PWM周期割込みでなければ
#ifdef ISR1				;固有の割込み処理1が必要なとき
		goto	intsr8			;　飛ぶ
#else
		retfie				;　割込み処理から復帰する
#endif
		bcf	PIRxPWM,PIRxPWMf	;PWM周期割込みﾌﾗｸﾞをｸﾘｱ

;PWMﾃﾞｭｰﾃｨ設定
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movfw	out_buf_r		;読込みﾎﾟｲﾝﾀを
		movwf	FSR0L			;　FSRに設定する
		incf	out_buf_r,W		;読込みﾎﾟｲﾝﾀを進めてみて
		xorlw	out_buf_end		;　ﾊﾞｯﾌｧの最後に
		btfsc	STATUS,Z		;　なったら
		movlw	out_buf^out_buf_end	;　先頭に
		xorlw	out_buf_end		;　戻す
		xorwf	out_buf_w,W		;書込みﾎﾟｲﾝﾀに
		btfsc	STATUS,Z		;　追い付いたら
		retfie				;　空振りさせる
		xorwf	out_buf_w,W		;読込みﾎﾟｲﾝﾀを
		movwf	out_buf_r		;　更新しておく
		clrf	FSR0H			;FSRの上位ﾊﾞｲﾄは0とする
		movfw	INDF0			;CCPﾃﾞｰﾀを取出す
		banksel	PWMxDC			;BANK設定
		movwf	PWMxDC			;CCPﾃﾞｭｰﾃｨｻｲｸﾙに設定する

;出力ﾊﾞｯﾌｧﾌﾗｯｼｭの同期
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movf	out_zan,F		;出力残数が
		btfss	STATUS,Z		;　0でないときは
		decf	out_zan,F		;　-1する

;固有の割込み処理0(PWMﾃﾞｭｰﾃｨ値更新後)
#ifdef ISR0				;固有の割込み処理0が必要なとき
		CALLCB	CB_ISR0			;固有の割込み処理0を呼ぶ
#endif
		retfie				;割込み処理から復帰する

;固有の割込み処理1(PWM周期割込み以外)
#ifdef ISR1				;固有の割込み処理1が必要なとき
intsr8
		CALLCB	CB_ISR1			;固有の割込み処理1を呼ぶ
#endif
		retfie				;割込み処理から復帰する


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;25ms待ち
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WAIT_25mS	clrf	mul_cH			;25ms待つ
		clrf	mul_cL
		decfsz	mul_cL,F
		goto	$-1
		clrwdt				;監視ﾀｲﾏｰをｸﾘｱ
		decfsz	mul_cH,F
		goto	$-3
		return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾒｲﾝﾙｰﾌﾟ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾘﾆｱﾃﾞｰﾀ領域のｸﾘｱ
main		movlw	low(LINEAR_BGN)		;開始ｱﾄﾞﾚｽを
		movwf	FSR0L			;　間接ｱﾄﾞﾚｯｼﾝｸﾞに設定する
		movlw	high(LINEAR_BGN)
		movwf	FSR0H
		movlw	low(LINEAR_LEN)		;長さを
		movwf	COMMON_BGN		;　繰返し回数に設定する
		movlw	high(LINEAR_LEN)+1	;decfszﾙｰﾌﾟのために+1しておく
		movwf	COMMON_BGN+1
		movf	COMMON_BGN,F
		btfsc	STATUS,Z
		decf	COMMON_BGN+1,F
main1		clrf	INDF0			;SRAMをｸﾘｱする
		incfsz	FSR0L,F			;ｱﾄﾞﾚｽを進めて
		decf	FSR0H,F
		incf	FSR0H,F
		decfsz	COMMON_BGN,F		;長さ分だけ繰返す
		goto	main1
		decfsz	COMMON_BGN+1,F
		goto	main1

;ﾊﾞﾝｸ共通ﾃﾞｰﾀ領域のｸﾘｱ
		movlw	COMMON_BGN		;開始ｱﾄﾞﾚｽを
		movwf	FSR0L			;　間接ｱﾄﾞﾚｯｼﾝｸﾞに設定する
		clrf	FSR0H
		movlw	COMMON_LEN		;長さを繰返し回数に設定する
main2		clrf	INDF0			;SRAMをｸﾘｱする
		incf	FSR0L,F			;ｱﾄﾞﾚｽを進める
		addlw	-1			;長さ分だけ繰返す
		btfss	STATUS,Z
		goto	main2

;共通ﾃﾞｰﾀの初期化
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movlw	out_buf
		movwf	out_buf_w
		movwf	out_buf_r
		bsf	koyuu_psL,0		;固有処理呼出しの
		bsf	koyuu_psH,0		;　ﾌﾟﾘｽｹｰﾗを最短にしておく

;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀの初期化
#if PART_N>0
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのBANK設定
		bsf	song_ps,0		;演奏ﾌﾟﾘｽｹｰﾗを最短にしておく
#endif

;音声再生ﾃﾞｰﾀの初期化
;#if VOICE_N+VOICE_I+VOICE_S>0
;		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
;		bsf	voice_pop_ps,0		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗを最短にしておく
;#endif
#if VOICE_N>0
		bsf	voice0_ps,0		;VOICE0ﾌﾟﾘｽｹｰﾗを最短にしておく
#endif
#if VOICE_N>1
		bsf	voice1_ps,0		;VOICE1ﾌﾟﾘｽｹｰﾗを最短にしておく
#endif
#if VOICE_N>2
		bsf	voice2_ps,0		;VOICE2ﾌﾟﾘｽｹｰﾗを最短にしておく
#endif
;#if VOICE_I>0
;		bsf	voiceI_ps,0		;VOICEIﾌﾟﾘｽｹｰﾗを最短にしておく
;#endif
;#if VOICE_S>0
;		bsf	voiceS_ps,0		;VOICESﾌﾟﾘｽｹｰﾗを最短にしておく
;#endif

;固有の初期設定
		CALLCB	CB_INIT			;固有の初期設定(ｺｰﾙﾊﾞｯｸ関数)を呼ぶ

;SDCの初期設定(固有の初期化で内蔵ﾓｼﾞｭｰﾙを初期化後に実行する)
;#if VOICE_S>0
;main3
;	;DEG_L	'i'
;		call	mmsd_init		;SDCを初期化する
;	;DEG_W
;		xorlw	0			;正常終了で
;		btfss	STATUS,Z		;　無かったら
;		goto	main3			;　ﾘﾄﾗｲする
;	;DEG_L	'|'
;#endif

;ここからﾒｲﾝﾙｰﾌﾟ

;固有処理の呼出し
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
main4		decfsz	koyuu_psL,F		;固有処理呼出しﾌﾟﾘｽｹｰﾗ下位ﾁｪｯｸ
		goto	main6
		decfsz	koyuu_psH,F		;固有処理呼出しﾌﾟﾘｽｹｰﾗ上位ﾁｪｯｸ
		goto	main6
		movlw	low(KOYUU_PS)+1		;固有処理呼出しﾌﾟﾘｽｹｰﾗを
		movwf	koyuu_psL		;　設定する
		movlw	high(KOYUU_PS)+1	;decfszﾙｰﾌﾟのため
		movwf	koyuu_psH		;　予め+1しておく
		CALLCB	CB_KOYUU		;固有の処理(ｺｰﾙﾊﾞｯｸ関数)を呼ぶ
main6

;#if VOICE_N+VOICE_I+VOICE_S>0
;;音声再生前処理
;		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
;		decfsz	voice_pop_ps,F		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗ内のときは
;		goto	main20			;　飛ぶ
;		movlw	POP_PS			;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾙ値を
;		movwf	voice_pop_ps		;　初期化しておく
;main20
;#endif

#if VOICE_N>0
;音声0再生処理
		movf	voice0_no,F		;音声再生中で
		btfsc	STATUS,Z		;　ないときは
		goto	main26			;　ﾗﾝﾌﾟ下降へ飛ぶ
		btfsc	voice0_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得のときは
		goto	main23			;　飛ぶ
		btfsc	voice0_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策中のときは
		goto	main24			;　飛ぶ
		decfsz	voice0_ps,F		;音声再生処理のﾀｲﾐﾝｸﾞでなければ
		goto	main29			;　処理を飛ばす
		movfw	voice0_psn		;音声再生処理ﾌﾟﾘｽｹｰﾗを
		movwf	voice0_ps		;　初期化する

;音声ﾃﾞｰﾀ再生処理
		call	playback0		;音声ﾃﾞｰﾀを取得する
main21		xorlw	1			;音声ﾃﾞｰﾀが
		btfsc	STATUS,Z		;　終了したら
		goto	main22			;　飛ぶ
		movfw	voice_out		;音声ﾃﾞｰﾀ取得値を
		movwf	voice0_out		;　音声出力値とする
		goto	main28
main22		clrf	voice0_no		;音声番号をｸﾘｱする
		CALLCB	CB_VOICE0_END		;音声再生終了時ｺｰﾙﾊﾞｯｸ関数を呼ぶ
		goto	main28

;ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ取得
main23		call	playback0		;最初のﾃﾞｰﾀを取得する
		bcf	voice0_no,VO_STS0_BIT	;最初のﾃﾞｰﾀを取得済みにする
		btfss	voice0_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策しないときは
		goto	main21			;　通常の再生処理へ飛ぶ
		movfw	voice_out		;最初の音声ﾃﾞｰﾀを
		movwf	voice0_pop		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに設定する

;音声再生前のﾗﾝﾌﾟ上昇/下降
main24		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
		goto	main28			;　残っていれば飛ぶ
		movfw	voice0_out		;出力値が
		subwf	voice0_pop,W		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに
		btfss	STATUS,Z		;　達してなければ
		goto	main25			;　飛ぶ
		bcf	voice0_no,VO_STS1_BIT	;音声ﾃﾞｰﾀ再生中にする
		goto	main28
main25		movlw	1			;仮にﾗﾝﾌﾟ上昇にしておく
		btfss	STATUS,C		;出力値がﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙを超えていたら
		movlw	-1			;　ﾗﾝﾌﾟ下降にする
		addwf	voice0_out,F		;ﾗﾝﾌﾟ波形を出力する
		goto	main28

;音声再生後のﾗﾝﾌﾟ下降
main26		movf	voice0_out,F		;出力値が
		btfsc	STATUS,Z		;　残っていなければ
		goto	main29			;　飛ぶ
		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
		goto	main28			;　残っていれば飛ぶ
		decf	voice0_out,F		;　出力値をﾃﾞｸﾘする
main28
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movlw	OUT_BUF_N		;出力ﾊﾞｯﾌｧを
		movwf	out_zan			;　ﾌﾙ表示しておく
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
main29
#endif

#if VOICE_N>1
;音声1再生処理
		movf	voice1_no,F		;音声再生中で
		btfsc	STATUS,Z		;　ないときは
		goto	main36			;　ﾗﾝﾌﾟ下降へ飛ぶ
		btfsc	voice1_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得のときは
		goto	main33			;　飛ぶ
		btfsc	voice1_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策中のときは
		goto	main34			;　飛ぶ
		decfsz	voice1_ps,F		;音声再生処理のﾀｲﾐﾝｸﾞでなければ
		goto	main39			;　処理を飛ばす
		movfw	voice1_psn		;音声再生処理ﾌﾟﾘｽｹｰﾗを
		movwf	voice1_ps		;　初期化する

;音声ﾃﾞｰﾀ再生処理
		call	playback1		;音声ﾃﾞｰﾀを取得する
main31		xorlw	1			;音声ﾃﾞｰﾀが
		btfsc	STATUS,Z		;　終了したら
		goto	main32			;　飛ぶ
		movfw	voice_out		;音声ﾃﾞｰﾀ取得値を
		movwf	voice1_out		;　音声出力値とする
		goto	main38
main32		clrf	voice1_no		;音声番号をｸﾘｱする
		CALLCB	CB_VOICE1_END		;音声再生終了時ｺｰﾙﾊﾞｯｸ関数を呼ぶ
		goto	main38

;ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ取得
main33		call	playback1		;最初のﾃﾞｰﾀを取得する
		bcf	voice1_no,VO_STS0_BIT	;最初のﾃﾞｰﾀを取得済みにする
		btfss	voice1_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策しないときは
		goto	main31			;　通常の再生処理へ飛ぶ
		movfw	voice_out		;最初の音声ﾃﾞｰﾀを
		movwf	voice1_pop		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに設定する

;音声再生前のﾗﾝﾌﾟ上昇/下降
main34		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
		goto	main38			;　残っていれば飛ぶ
		movfw	voice1_out		;出力値が
		subwf	voice1_pop,W		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに
		btfss	STATUS,Z		;　達してなければ
		goto	main35			;　飛ぶ
		bcf	voice1_no,VO_STS1_BIT	;音声ﾃﾞｰﾀ再生中にする
		goto	main38
main35		movlw	1			;仮にﾗﾝﾌﾟ上昇にしておく
		btfss	STATUS,C		;出力値がﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙを超えていたら
		movlw	-1			;　ﾗﾝﾌﾟ下降にする
		addwf	voice1_out,F		;ﾗﾝﾌﾟ波形を出力する
		goto	main38

;音声再生後のﾗﾝﾌﾟ下降
main36		movf	voice1_out,F		;出力値が
		btfsc	STATUS,Z		;　残っていなければ
		goto	main39			;　飛ぶ
		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
		goto	main38			;　残っていれば飛ぶ
		decf	voice1_out,F		;　出力値をﾃﾞｸﾘする
main38
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movlw	OUT_BUF_N		;出力ﾊﾞｯﾌｧを
		movwf	out_zan			;　ﾌﾙ表示しておく
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
main39
#endif

#if VOICE_N>2
;音声2再生処理
		movf	voice2_no,F		;音声再生中で
		btfsc	STATUS,Z		;　ないときは
		goto	main46			;　ﾗﾝﾌﾟ下降へ飛ぶ
		btfsc	voice2_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得のときは
		goto	main43			;　飛ぶ
		btfsc	voice2_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策中のときは
		goto	main44			;　飛ぶ
		decfsz	voice2_ps,F		;音声再生処理のﾀｲﾐﾝｸﾞでなければ
		goto	main49			;　処理を飛ばす
		movfw	voice2_psn		;音声再生処理ﾌﾟﾘｽｹｰﾗを
		movwf	voice2_ps		;　初期化する

;音声ﾃﾞｰﾀ再生処理
		call	playback2		;音声ﾃﾞｰﾀを取得する
main41		xorlw	1			;音声ﾃﾞｰﾀが
		btfsc	STATUS,Z		;　終了したら
		goto	main42			;　飛ぶ
		movfw	voice_out		;音声ﾃﾞｰﾀ取得値を
		movwf	voice2_out		;　音声出力値とする
		goto	main48
main42		clrf	voice2_no		;音声番号をｸﾘｱする
		CALLCB	CB_VOICE2_END		;音声再生終了時ｺｰﾙﾊﾞｯｸ関数を呼ぶ
		goto	main48

;ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ取得
main43		call	playback2		;最初のﾃﾞｰﾀを取得する
		bcf	voice2_no,VO_STS0_BIT	;最初のﾃﾞｰﾀを取得済みにする
		btfss	voice2_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策しないときは
		goto	main41			;　通常の再生処理へ飛ぶ
		movfw	voice_out		;最初の音声ﾃﾞｰﾀを
		movwf	voice2_pop		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに設定する

;音声再生前のﾗﾝﾌﾟ上昇/下降
main44		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
		goto	main48			;　残っていれば飛ぶ
		movfw	voice2_out		;出力値が
		subwf	voice2_pop,W		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに
		btfss	STATUS,Z		;　達してなければ
		goto	main45			;　飛ぶ
		bcf	voice2_no,VO_STS1_BIT	;音声ﾃﾞｰﾀ再生中にする
		goto	main48
main45		movlw	1			;仮にﾗﾝﾌﾟ上昇にしておく
		btfss	STATUS,C		;出力値がﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙを超えていたら
		movlw	-1			;　ﾗﾝﾌﾟ下降にする
		addwf	voice2_out,F		;ﾗﾝﾌﾟ波形を出力する
		goto	main48

;音声再生後のﾗﾝﾌﾟ下降
main46		movf	voice2_out,F		;出力値が
		btfsc	STATUS,Z		;　残っていなければ
		goto	main49			;　飛ぶ
		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
		goto	main48			;　残っていれば飛ぶ
		decf	voice2_out,F		;　出力値をﾃﾞｸﾘする
main48
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movlw	OUT_BUF_N		;出力ﾊﾞｯﾌｧを
		movwf	out_zan			;　ﾌﾙ表示しておく
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
main49
#endif

;#if VOICE_I>0
;;音声I再生処理
;	;DEG_L	'm'
;	;DEG_F	voiceI_no
;		movf	voiceI_no,F		;音声再生中で
;		btfsc	STATUS,Z		;　ないときは
;		goto	main56			;　ﾗﾝﾌﾟ下降へ飛ぶ
;		btfsc	voiceI_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得のときは
;		goto	main53			;　飛ぶ
;		btfsc	voiceI_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策中のときは
;		goto	main54			;　飛ぶ
;		decfsz	voiceI_ps,F		;音声再生処理のﾀｲﾐﾝｸﾞでなければ
;		goto	main59			;　処理を飛ばす
;		movfw	voiceI_psn		;音声再生処理ﾌﾟﾘｽｹｰﾗを
;		movwf	voiceI_ps		;　初期化する
;
;;音声ﾃﾞｰﾀ再生処理
;		call	playbackI		;音声ﾃﾞｰﾀを取得する
;	;DEG_W
;main51		xorlw	1			;音声ﾃﾞｰﾀが
;		btfsc	STATUS,Z		;　終了したら
;		goto	main52			;　飛ぶ
;	;DEG_F	voice_out
;		movfw	voice_out		;音声ﾃﾞｰﾀ取得値を
;		movwf	voiceI_out		;　音声出力値とする
;		goto	main58
;main52		movlw	~VO_STS_MSK		;音声番号が
;		andwf	voiceI_no,W		;　0かﾁｪｯｸする
;		clrf	voiceI_no		;音声番号をｸﾘｱする
;		btfsc	STATUS,Z		;音声番号が0だったときは
;		goto	main58			;　音声再生終了時ｺｰﾙﾊﾞｯｸ関数を呼ばない
;		CALLCB	CB_VOICEI_END		;音声再生終了時ｺｰﾙﾊﾞｯｸ関数を呼ぶ
;		goto	main58
;
;;ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ取得
;main53		call	playbackI		;最初のﾃﾞｰﾀを取得する
;		bcf	voiceI_no,VO_STS0_BIT	;最初のﾃﾞｰﾀを取得済みにする
;		btfss	voiceI_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策しないときは
;		goto	main51			;　通常の再生処理へ飛ぶ
;	;DEG_L	'p'
;	;DEG_W
;		movfw	voice_out		;最初の音声ﾃﾞｰﾀを
;		movwf	voiceI_pop		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに設定する
;
;;音声再生前のﾗﾝﾌﾟ上昇/下降
;main54		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
;		goto	main58			;　残っていれば飛ぶ
;		movfw	voiceI_out		;出力値が
;	;DEG_F	voiceI_out
;		subwf	voiceI_pop,W		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに
;		btfss	STATUS,Z		;　達してなければ
;		goto	main55			;　飛ぶ
;		bcf	voiceI_no,VO_STS1_BIT	;音声ﾃﾞｰﾀ再生中にする
;		goto	main58
;main55		movlw	1			;仮にﾗﾝﾌﾟ上昇にしておく
;		btfss	STATUS,C		;出力値がﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙを超えていたら
;		movlw	-1			;　ﾗﾝﾌﾟ下降にする
;		addwf	voiceI_out,F		;ﾗﾝﾌﾟ波形を出力する
;		goto	main58
;
;;音声再生後のﾗﾝﾌﾟ下降
;main56		movf	voiceI_out,F		;出力値が
;		btfsc	STATUS,Z		;　残っていなければ
;		goto	main59			;　飛ぶ
;		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
;		goto	main58			;　残っていれば飛ぶ
;		decf	voiceI_out,F		;　出力値をﾃﾞｸﾘする
;	;DEG_L	'k'
;	;DEG_F	voiceI_out
;main58
;		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
;		movlw	OUT_BUF_N		;出力ﾊﾞｯﾌｧを
;		movwf	out_zan			;　ﾌﾙ表示しておく
;						;音声再生の最後なのでﾊﾞﾝｸ戻しはしない
;main59
;#endif
;
;#if VOICE_S>0
;;音声S再生処理
;	;DEG_L	'm'
;	;DEG_F	voiceS_no
;		movf	voiceS_no,F		;音声再生中で
;		btfsc	STATUS,Z		;　ないときは
;		goto	main66			;　ﾗﾝﾌﾟ下降へ飛ぶ
;		btfsc	voiceS_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得のときは
;		goto	main63			;　飛ぶ
;		btfsc	voiceS_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策中のときは
;		goto	main64			;　飛ぶ
;		decfsz	voiceS_ps,F		;音声再生処理のﾀｲﾐﾝｸﾞでなければ
;		goto	main69			;　処理を飛ばす
;		movfw	voiceS_psn		;音声再生処理ﾌﾟﾘｽｹｰﾗを
;		movwf	voiceS_ps		;　初期化する
;
;;音声ﾃﾞｰﾀ再生処理
;		call	playbackS		;音声ﾃﾞｰﾀを取得する
;	;DEG_W
;main61		xorlw	1			;音声ﾃﾞｰﾀが
;		btfsc	STATUS,Z		;　終了したら
;		goto	main62			;　飛ぶ
;	;DEG_F	voice_out
; 		movfw	voice_out		;音声ﾃﾞｰﾀ取得値を
;		movwf	voiceS_out		;　音声出力値とする
;		goto	main68
;main62		movlw	~VO_STS_MSK		;音声番号が
;		andwf	voiceS_no,W		;　0かﾁｪｯｸする
;		clrf	voiceS_no		;音声番号をｸﾘｱする
;		btfsc	STATUS,Z		;音声番号が0だったときは
;		goto	main68			;　音声再生終了時ｺｰﾙﾊﾞｯｸ関数を呼ばない
;		CALLCB	CB_VOICES_END		;音声再生終了時ｺｰﾙﾊﾞｯｸ関数を呼ぶ
;		goto	main68
;
;;ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙ取得
;main63		call	playbackS		;最初のﾃﾞｰﾀを取得する
;		xorlw	2			;ﾍﾟｰｼﾞの先頭で
;		btfss	STATUS,Z		;　なかったら
;		goto	main68			;　ﾃﾞｰﾀを読み捨てる
;		bcf	voiceS_no,VO_STS0_BIT	;最初のﾃﾞｰﾀを取得済みにする
;		btfss	voiceS_no,VO_STS1_BIT	;ﾎﾟｯﾌﾟﾉｲｽﾞ対策しないときは
;		goto	main61			;　通常の再生処理へ飛ぶ
;	;DEG_L	'p'
;	;DEG_W
;		movfw	voice_out		;最初の音声ﾃﾞｰﾀを
;		movwf	voiceS_pop		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに設定する
;
;;音声再生前のﾗﾝﾌﾟ上昇/下降
;main64		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
;		goto	main68			;　残っていれば飛ぶ
;		movfw	voiceS_out		;出力値が
;	;DEG_F	voiceS_out
;		subwf	voiceS_pop,W		;　ﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙに
;		btfss	STATUS,Z		;　達してなければ
;		goto	main65			;　飛ぶ
;		bcf	voiceS_no,VO_STS1_BIT	;音声ﾃﾞｰﾀ再生中にする
;		goto	main68
;main65		movlw	1			;仮にﾗﾝﾌﾟ上昇にしておく
;		btfss	STATUS,C		;出力値がﾎﾟｯﾌﾟﾉｲｽﾞﾚﾍﾞﾙを超えていたら
;		movlw	-1			;　ﾗﾝﾌﾟ下降にする
;		addwf	voiceS_out,F		;ﾗﾝﾌﾟ波形を出力する
;		goto	main68
;
;;音声再生後のﾗﾝﾌﾟ下降
;main66		movf	voiceS_out,F		;出力値が
;		btfsc	STATUS,Z		;　残っていなければ
;		goto	main69			;　飛ぶ
;		decfsz	voice_pop_ps,W		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
;		goto	main68			;　残っていれば飛ぶ
;		decf	voiceS_out,F		;　出力値をﾃﾞｸﾘする
;	;DEG_L	'k'
;	;DEG_F	voiceS_out
;main68
;		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
;		movlw	OUT_BUF_N		;出力ﾊﾞｯﾌｧを
;		movwf	out_zan			;　ﾌﾙ表示しておく
;						;音声再生の最後なのでﾊﾞﾝｸ戻しはしない
;main69
;#endif

#if PART_N>0
;ｵﾙｺﾞｰﾙ演奏処理
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movf	song_no,F		;演奏中で
		btfsc	STATUS,Z		;　ないときは
		goto	main74			;　演奏処理を飛ばす
		decfsz	song_ps,F		;演奏処理のﾀｲﾐﾝｸﾞでなければ
		goto	main78			;　演奏処理を飛ばす
		movlw	SONG_PS			;演奏ﾌﾟﾘｽｹｰﾗを
		movwf	song_ps			;　初期化する
		call	orgel			;演奏処理を実行する
		movf	song_sts,F		;全ﾊﾟｰﾄの演奏が
		btfss	STATUS,Z		;　終了していなかったら
		goto	main76			;　飛ぶ
		clrf	song_no			;曲番号をｸﾘｱ
		CALLCB	CB_SONG_END		;演奏終了時ｺｰﾙﾊﾞｯｸ関数を呼ぶ
		goto	main76

;演奏終了後のﾗﾝﾌﾟ下降
main74		movf	song_out,F		;出力値が
		btfsc	STATUS,Z		;　残っていなければ
		goto	main78			;　飛ぶ
		decfsz	song_pop_ps,F		;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗが
		goto	main78			;　残っていれば飛ぶ
		movlw	POP_PS			;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗを
		movwf	song_pop_ps		;　初期化する
		decf	song_out,F		;　出力値をﾃﾞｸﾘする
main76
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movlw	OUT_BUF_N		;出力ﾊﾞｯﾌｧを
		movwf	out_zan			;　ﾌﾙ表示しておく

main78
#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;出力合成処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;出力ﾊﾞｯﾌｧの空きﾁｪｯｸ
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
out		movfw	out_buf_w		;書込みﾎﾟｲﾝﾀが
		xorwf	out_buf_r,W		;　読込みﾎﾟｲﾝﾀと
		btfsc	STATUS,Z		;　同じときは
		goto	out			;　空きができるまで待つ

;出力ﾊﾞｯﾌｧのｵﾌｾｯﾄを設定
		movfw	out_buf_w		;出力ﾊﾞｯﾌｧの書込みﾎﾟｲﾝﾀを設定
		movwf	FSR0L
		clrf	FSR0H

;出力値を設定
		clrf	mul_wk			;合算値をｸﾘｱしておく(乗算作業域を流用)
		clrf	mul_a			;ｵｰﾊﾞﾌﾛｰ桁もｸﾘｱしておく(乗算作業域を流用)
#if PART_N>0
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movfw	song_out		;出力値を得る
		btfsc	mute_sts,MUTE_ORGEL_BIT	;ﾐｭｰﾄ設定があれば
		lsrf	song_out,W		;　1/2にする
		addwf	mul_wk,F		;合算する
#endif
;#if (VOICE_N+VOICE_I+VOICE_S)>0
;		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
;#endif
#if VOICE_N>0
		movfw	voice0_out		;出力値を得る
		btfsc	mute_sts,MUTE_VO0_BIT	;ﾐｭｰﾄ設定があれば
		lsrf	voice0_out,W		;　1/2にする
		addwf	mul_wk,F		;合算する
		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
		incf	mul_a,F			;　ｵｰﾊﾞﾌﾛｰ桁をｲﾝｸﾘする
#endif
#if VOICE_N>1
		movfw	voice1_out		;出力値を得る
		btfsc	mute_sts,MUTE_VO1_BIT	;ﾐｭｰﾄ設定があれば
		lsrf	voice1_out,W		;　1/2にする
		addwf	mul_wk,F		;合算する
		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
		incf	mul_a,F			;　ｵｰﾊﾞﾌﾛｰ桁をｲﾝｸﾘする
#endif
#if VOICE_N>2
		movfw	voice2_out		;出力値を得る
		btfsc	mute_sts,MUTE_VO2_BIT	;ﾐｭｰﾄ設定があれば
		lsrf	voice2_out,W		;　1/2にする
		addwf	mul_wk,F		;合算する
		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
		incf	mul_a,F			;　ｵｰﾊﾞﾌﾛｰ桁をｲﾝｸﾘする
#endif
;#if VOICE_I>0
;		movfw	voiceI_out		;出力値を得る
;		btfsc	mute_sts,MUTE_VOI_BIT	;ﾐｭｰﾄ設定があれば
;		lsrf	voiceI_out,W		;　1/2にする
;		addwf	mul_wk,F		;合算する
;		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
;		incf	mul_a,F			;　ｵｰﾊﾞﾌﾛｰ桁をｲﾝｸﾘする
;#endif
;#if VOICE_S>0
;		movfw	voiceS_out		;出力値を得る
;		btfsc	mute_sts,MUTE_VOS_BIT	;ﾐｭｰﾄ設定があれば
;		lsrf	voiceS_out,W		;　1/2にする
;		addwf	mul_wk,F		;合算する
;		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
;		incf	mul_a,F			;　ｵｰﾊﾞﾌﾛｰ桁をｲﾝｸﾘする
;#endif
		movlw	PWM_CT-1		;仮に結果を最大値にしておく
		movf	mul_a,F			;ｵｰﾊﾞﾌﾛｰしていたら
		btfss	STATUS,Z		;　最大値に決定
		goto	out4
		subwf	mul_wk,W		;合算値が
		btfsc	STATUS,C		;　最大値を
		movlw	0			;　超えていたら
		addlw	PWM_CT-1		;　最大値に抑える
out4		movwi	0[FSR0]			;　出力ﾊﾞｯﾌｧに格納
	;DEG_W

;出力ﾊﾞｯﾌｧの書込みﾎﾟｲﾝﾀを進める
out8
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		incf	out_buf_w,W		;書込みﾎﾟｲﾝﾀを進めてみて
		xorlw	out_buf_end		;　ﾊﾞｯﾌｧの最後に
		btfsc	STATUS,Z		;　なったら
		movlw	out_buf^out_buf_end	;　最初に
		xorlw	out_buf_end		;　戻す
		movwf	out_buf_w		;書込みﾎﾟｲﾝﾀを設定する
		goto	main4			;ﾒｲﾝﾙｰﾌﾟを繰返す

;ここまでﾒｲﾝﾙｰﾌﾟ


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾐｭｰﾄ設定処理(API関数)
;input W:ﾐｭｰﾄ設定値
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MUTE_SET
		movwf	mute_sts		;ﾐｭｰﾄ設定値を取込む
		return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;出力ﾊﾞｯﾌｧのﾃﾞｰﾀ数取得処理(API関数)
;output W:出力ﾊﾞｯﾌｧのﾃﾞｰﾀ数
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BUF_CHK
		movfw	BSR			;BSRを
		movwf	api_bsr			;　退避する
		banksel	KYO_BANK		;共通ﾃﾞｰﾀのBANK設定
		movfw	out_zan			;出力ﾊﾞｯﾌｧのﾃﾞｰﾀ数を
		movwf	mul_wk			;　共通ﾊﾞﾝｸに退避しておく
		movfw	api_bsr			;BSRを
		movwf	BSR			;　回復する
		movfw	mul_wk			;出力ﾊﾞｯﾌｧのﾃﾞｰﾀ数を返す
		return


#if PART_N>0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;曲選択処理(API関数)
;input W:曲番号(0=演奏中断､1〜255=指定曲番号を演奏開始)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;演奏中の曲番号とのﾁｪｯｸ
SONG_SEL	xorwf	song_no,W		;演奏中の曲番号と
		btfsc	STATUS,Z		;　同じだったら
		return				;　無効果で戻る
		xorwf	song_no,W		;曲番号を復元する

;曲番号を評価
		addlw	-1			;曲番号が
		btfsc	STATUS,C		;　1以上のときは
		goto	song_sel2		;　飛ぶ

;演奏を中断
		movfw	BSR			;BSRを
		movwf	api_bsr			;　退避する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		clrf	song_no			;制御情報をｸﾘｱする
		clrf	song_sts
		movlw	POP_PS			;ﾎﾟｯﾌﾟﾉｲｽﾞ抑止ﾌﾟﾘｽｹｰﾗを
		movwf	song_pop_ps		;　初期化する
		movfw	api_bsr			;BSRを
		movwf	BSR			;　回復する
		return

;曲番号の実装ﾁｪｯｸ
song_sel2
		addlw	1			;曲番号を復元する
		addlw	-((song_tbl_end-song_tbl)/2+1)
						;曲番号が実装曲数以内で
		btfsc	STATUS,C		;　なかったら
		return				;　無効果で戻る
		addlw	(song_tbl_end-song_tbl)/2+1
						;曲番号を復元する
		movwf	song_no			;曲番号を記憶しておく

;演奏作業域をｸﾘｱ
		movfw	BSR			;BSRを
		movwf	api_bsr			;　退避する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		clrf	song_sts		;ｽﾃｰﾀｽを初期化する
		movlw	1			;演奏胥吏ﾌﾟﾘｽｹｰﾗを
		movwf	song_ps			;　最短にする

;選択された曲のｿﾝｸﾞﾃﾞｰﾀﾍｯﾀﾞ部のｱﾄﾞﾚｽをFSR1に取得
		clrf	FSR0H			;ｿﾝｸﾞﾃｰﾌﾞﾙの
		lslf	song_no,W		;　ｲﾝﾃﾞｯｸｽを
		movwf	FSR0L			;　FSR0に
		movlw	high(song_tbl-2)	;　設定する
		addwfc	FSR0H,F
		movlw	low(song_tbl-2)
		addwf	FSR0L,F
		movlw	0
		addwfc	FSR0H,F
		moviw	PTR_L[FSR0]		;ｿﾝｸﾞﾃﾞｰﾀﾍｯﾀﾞ部の
		movwf	FSR1L			;　ｱﾄﾞﾚｽを
		moviw	PTR_H[FSR0]		;　FSR1に
		movwf	FSR1H			;　取得する

;ﾊﾟｰﾄ共通演奏制御ﾃﾞｰﾀの初期化
		moviw	HDR_ONKA_PS[FSR1]	;ﾍｯﾀﾞの音価ﾌﾟﾘｽｹｰﾙ値を
		movwf	onka_psn		;　音価ﾌﾟﾘｽｹｰﾙ値に設定
		moviw	HDR_PART_SU[FSR1]	;ﾍｯﾀﾞの実装ﾊﾟｰﾄ数を
		movwf	part_su			;　実装ﾊﾟｰﾄ数に設定
		movlw	1
		movwf	onka_ps			;音価ﾌﾟﾘｽｹｰﾗを最短にしておく
		movwf	tempo_ps		;ﾃﾝﾎﾟﾌﾟﾘｽｹｰﾗを最短にしておく

;ﾊﾟｰﾄ0演奏制御ﾃﾞｰﾀの初期化
		clrf	part0_step
		clrf	part0_sts
		clrf	part0_ongen_ofF
		clrf	part0_ongen_ofL
		clrf	part0_ongen_ofH
		clrf	part0_enve
		movlw	1
		movwf	part0_onka_zan		;音価残を最短にしておく
		bsf	song_sts,STS_PART0_BIT	;ﾊﾟｰﾄを演奏中にする

;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART0_ONGEN_L[FSR1]	;音源波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART0_ONGEN_H[FSR1]
		movwf	FSR0H
		moviw	WAVE_N_F[FSR0]		;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part0_ongen_nF
		moviw	WAVE_N_L[FSR0]
		movwf	part0_ongen_nL
		moviw	WAVE_N_H[FSR0]
		movwf	part0_ongen_nH

;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART0_ENVE_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART0_ENVE_H[FSR1]
		movwf	FSR0H
		moviw	ENVE_N[FSR0]		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part0_enve_n

#if PITCH_N>0
;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART0_PITCH_L[FSR1]	;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART0_PITCH_H[FSR1]
		movwf	FSR0H
		moviw	ENVE_N[FSR0]		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part0_pitch_n
#endif

#if PART_N>1
;ﾊﾟｰﾄ1演奏制御ﾃﾞｰﾀの初期化
		movlw	-2			;ﾊﾟｰﾄが
		addwf	part_su,W		;　未実装の
		btfss	STATUS,C		;　ときは
		goto	song_sel11		;　飛ぶ
		clrf	part1_step
		clrf	part1_sts
		clrf	part1_ongen_ofF
		clrf	part1_ongen_ofL
		clrf	part1_ongen_ofH
		clrf	part1_enve
		movlw	1
		movwf	part1_onka_zan		;音価残を最短にしておく
		bsf	song_sts,STS_PART1_BIT	;ﾊﾟｰﾄを演奏中にする

;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART1_ONGEN_L[FSR1]	;音源波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART1_ONGEN_H[FSR1]
		movwf	FSR0H
		moviw	WAVE_N_F[FSR0]
		movwf	part1_ongen_nF
		moviw	WAVE_N_L[FSR0]		;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part1_ongen_nL
		moviw	WAVE_N_H[FSR0]
		movwf	part1_ongen_nH

;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART1_ENVE_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART1_ENVE_H[FSR1]
		movwf	FSR0H
		moviw	ENVE_N[FSR0]		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part1_enve_n

#if PITCH_N>1
;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART1_PITCH_L[FSR1]	;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART1_PITCH_H[FSR1]
		movwf	FSR0H
		moviw	ENVE_N[FSR0]		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part1_pitch_n
#endif
song_sel11
#endif

#if PART_N>2
;ﾊﾟｰﾄ2演奏制御ﾃﾞｰﾀの初期化
		movlw	-3			;ﾊﾟｰﾄが
		addwf	part_su,W		;　未実装の
		btfss	STATUS,C		;　ときは
		goto	song_sel21		;　飛ぶ
		clrf	part2_step
		clrf	part2_sts
		clrf	part2_ongen_ofF
		clrf	part2_ongen_ofL
		clrf	part2_ongen_ofH
		clrf	part2_enve
		movlw	1
		movwf	part2_onka_zan		;音価残を最短にしておく
		bsf	song_sts,STS_PART2_BIT	;ﾊﾟｰﾄを演奏中にする

;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART2_ONGEN_L[FSR1]	;音源波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART2_ONGEN_H[FSR1]
		movwf	FSR0H
		moviw	WAVE_N_F[FSR0]		;音源波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part2_ongen_nF
		moviw	WAVE_N_L[FSR0]
		movwf	part2_ongen_nL
		moviw	WAVE_N_H[FSR0]
		movwf	part2_ongen_nH

;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART2_ENVE_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART2_ENVE_H[FSR1]
		movwf	FSR0H
		moviw	ENVE_N[FSR0]		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part2_enve_n

#if PITCH_N>2
;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数
		moviw	HDR_PART2_PITCH_L[FSR1]	;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀのｱﾄﾞﾚｽを設定
		movwf	FSR0L
		moviw	HDR_PART2_PITCH_H[FSR1]
		movwf	FSR0H
		moviw	ENVE_N[FSR0]		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃﾞｰﾀｻﾝﾌﾟﾙ数を取込む
		movwf	part2_pitch_n
#endif
song_sel21
#endif
		movfw	api_bsr			;BSRを
		movwf	BSR			;　回復する
		return
#endif


#if PART_N>0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾟｰﾄ0の音符ﾃﾞｰﾀ取得
;output W:取得した音符ﾃﾞｰﾀ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
part0_get_onpu	moviw	HDR_PART0_ONPU_H[FSR1]	;音符ﾃﾞｰﾀの
		movwf	FSR0H			;　ｱﾄﾞﾚｽを
		moviw	HDR_PART0_ONPU_L[FSR1]	;　取得
		movwf	FSR0L			;　する
		movfw	part0_step		;音符ｽﾃｯﾌﾟを
		addwf	FSR0L,F			;　ｵﾌｾｯﾄに
		btfsc	STATUS,C		;　加算する
		incf	FSR0H,F
		incf	part0_step,F		;音符ｽﾃｯﾌﾟを進めておく
		moviw	0[FSR0]			;音符ﾃﾞｰﾀを取得する
		return
#endif


#if PART_N>1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾟｰﾄ1の音符ﾃﾞｰﾀ取得
;output W:取得した音符ﾃﾞｰﾀ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
part1_get_onpu	moviw	HDR_PART1_ONPU_H[FSR1]	;音符ﾃﾞｰﾀの
		movwf	FSR0H			;　ｱﾄﾞﾚｽを
		moviw	HDR_PART1_ONPU_L[FSR1]	;　取得
		movwf	FSR0L			;　する
		movfw	part1_step		;音符ｽﾃｯﾌﾟを
		addwf	FSR0L,F			;　ｵﾌｾｯﾄに
		btfsc	STATUS,C		;　加算する
		incf	FSR0H,F
		incf	part1_step,F		;音符ｽﾃｯﾌﾟを進めておく
		moviw	0[FSR0]			;音符ﾃﾞｰﾀを取得する
		return
#endif


#if PART_N>2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾟｰﾄ2の音符ﾃﾞｰﾀ取得
;output W:取得した音符ﾃﾞｰﾀ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
part2_get_onpu	moviw	HDR_PART2_ONPU_H[FSR1]	;音符ﾃﾞｰﾀの
		movwf	FSR0H			;　ｱﾄﾞﾚｽを
		moviw	HDR_PART2_ONPU_L[FSR1]	;　取得
		movwf	FSR0L			;　する
		movfw	part2_step		;音符ｽﾃｯﾌﾟを
		addwf	FSR0L,F			;　ｵﾌｾｯﾄに
		btfsc	STATUS,C		;　加算する
		incf	FSR0H,F
		incf	part2_step,F		;音符ｽﾃｯﾌﾟを進めておく
		moviw	0[FSR0]			;音符ﾃﾞｰﾀを取得する
		return
#endif


#if PART_N>0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ｵﾙｺﾞｰﾙ演奏前処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾟｰﾄ共通のﾌﾟﾘｽｹｰﾗ処理
orgel		bcf	song_sts,ONKA_FULL_BIT	;音価ﾌﾟﾘｽｹｰﾗのﾌﾙ表示をｸﾘｱ
		decfsz	onka_ps,F		;音価ﾌﾟﾘｽｹｰﾗを-1して
		goto	orgel5			;　残があれば演奏に進む
		movfw	onka_psn		;音価ﾌﾟﾘｽｹｰﾙ値を設定
		movwf	onka_ps
		decfsz	tempo_ps,F		;ﾃﾝﾎﾟﾌﾟﾘｽｹｰﾗを-1して
		goto	orgel5			;　残があれば演奏に進む
		movlw	TEMPO_PS		;ﾃﾝﾎﾟﾌﾟﾘｽｹｰﾙ値を設定
		movwf	tempo_ps
		bsf	song_sts,ONKA_FULL_BIT	;音価ﾌﾟﾘｽｹｰﾗのﾌﾙ表示をｾｯﾄ

;ﾊﾟｰﾄ演奏処理開始
orgel5		clrf	song_out		;演奏出力値をｸﾘｱしておく


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾟｰﾄ0演奏処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		btfss	song_sts,STS_PART0_BIT	;演奏終了していたら
		goto	part0_999		;　ﾊﾟｰﾄ処理を飛ばす

;演奏中ｽﾃｯﾌﾟの音価ｶｳﾝﾄ残をﾁｪｯｸ
		btfss	song_sts,ONKA_FULL_BIT	;音価ﾌﾟﾘｽｹｰﾗがﾌﾙでなかったら
		goto	part0_7			;　音価残のﾁｪｯｸを飛ばす
		decfsz	part0_onka_zan,F	;音価ｶｳﾝﾄ残を-1して残があれば
		goto	part0_7			;　ｴﾝﾍﾞﾛｰﾌﾟ処理へ飛ぶ

;次の音符に進む
part0_1		call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part0_onpu		;音符ｺｰﾄﾞを保存する
		
;音価ｶｳﾝﾄを取出す
		swapf	part0_onpu,F		;音符ﾃﾞｰﾀから
		rrf	part0_onpu,W		;　音価ｺｰﾄﾞを
		swapf	part0_onpu,F		;　取出す
		andlw	0x07			;音価ｺｰﾄﾞが
		btfsc	STATUS,Z		;　0のときは
		goto	part0_5			;　終了か修飾処理へ飛ぶ
		movwf	FSR0L			;音価ﾃｰﾌﾞﾙｴﾝﾄﾘの
		moviw	HDR_PART0_ONKA_H[FSR1]	;　ｱﾄﾞﾚｽを
		movwf	FSR0H			;　計算する
		moviw	HDR_PART0_ONKA_L[FSR1]
		addwf	FSR0L,F
		btfsc	STATUS,C
		incf	FSR0H,F
		moviw	-1[FSR0]		;音価ｶｳﾝﾄを
		movwf	part0_onka_zan		;　取得する

;休符/発音音符ﾁｪｯｸ
		movfw	part0_onpu		;音符ﾃﾞｰﾀの
		andlw	0x1f			;　音高ｺｰﾄﾞが
		btfsc	STATUS,Z		;　0のときは
		goto	part0_4			;　休符処理へ飛ぶ
		bsf	part0_sts,PART_ON_BIT	;発音音符を表示する

;音高ｺｰﾄﾞから音源波形ｻﾝﾌﾟﾙ飛び数を取出す
		addlw	-1			;音高ｺｰﾄﾞ-1を音高ﾃｰﾌﾞﾙのｵﾌｾｯﾄ値とする
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART0_ONKOU_H[FSR1]	;音高ﾃｰﾌﾞﾙのｱﾄﾞﾚｽを取得する
		movwf	EEADRH
		moviw	HDR_PART0_ONKOU_L[FSR1]
		addwf	EEADRL,F		;音高ﾃｰﾌﾞﾙのｵﾌｾｯﾄ値に加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		movfw	EEDATL			;音源波形ｻﾝﾌﾟﾙ飛び数を取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	part0_ongen_tobiF
		banksel	EEDATH			;BANK設定
		movfw	EEDATH
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	part0_ongen_tobiL

;音符の属性を初期化する
part0_3		btfsc	part0_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ演奏のときは
		goto	part0_71		;　飛ぶ
		clrf	part0_enve_ps		;ｴﾝﾍﾞﾛｰﾌﾟ処理を
		bsf	part0_enve_ps,0		;　初期化する
		clrf	part0_enve_pss
		bsf	part0_enve_pss,0
		clrf	part0_enve_of
#if PITCH_N>0
		clrf	part0_pitch_ps		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理を
		bsf	part0_pitch_ps,0	;　初期化する
		clrf	part0_pitch_pss
		bsf	part0_pitch_pss,0
		clrf	part0_pitch_of
#endif
		goto	part0_71		;ｴﾝﾍﾞﾛｰﾌﾟ処理へ飛ぶ

;休符のとき
part0_4		bcf	part0_sts,PART_ON_BIT	;休符を表示する
		clrf	part0_velo_enve		;ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値を0にする
		goto	part0_999		;ﾊﾟｰﾄ処理を飛ばす

;終了か修飾のとき
part0_5		movfw	part0_onpu		;修飾ｺｰﾄﾞで
		brw				;　分岐する
		goto	part0_51		;終了のとき
		goto	part0_52		;無条件分岐のとき
		goto	part0_53		;ﾘﾋﾟｰﾄ1回数設定のとき
		goto	part0_54		;ﾘﾋﾟｰﾄ1分岐のとき
		goto	part0_56		;ﾘﾋﾟｰﾄ2回数設定のとき
		goto	part0_57		;ﾘﾋﾟｰﾄ2分岐のとき
		goto	part0_59		;ﾍﾞﾛｼﾃｨ設定のとき
		goto	part0_6			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定のとき
		goto	part0_61		;直指定音符のとき
		goto	part0_62		;ﾃﾝﾎﾟ指定のとき
		goto	part0_63		;ﾀｲ･ｽﾗｰ開始のとき
		goto	part0_64		;ﾀｲ･ｽﾗｰ終了のとき

;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定のとき
		call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
#if PITCH_N>0
		movwf	part0_pitch		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値を保存する
#endif
		goto	part0_1			;次の音符に進む

;終了のとき
part0_51	bcf	song_sts,STS_PART0_BIT	;演奏終了にする
		goto	part0_999		;ﾊﾟｰﾄ処理を飛ばす

;無条件分岐のとき
part0_52	call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part0_step		;音符ｽﾃｯﾌﾟを保管する
		goto	part0_1			;次の音符に進む

;ﾘﾋﾟｰﾄ1回数設定のとき
part0_53	movlw	0xf0			;古いﾘﾋﾟｰﾄ回数を
		andwf	part0_repeat,F		;　ｸﾘｱしておく
		call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		andlw	0x0f			;ﾘﾋﾟｰﾄ回数を
		iorwf	part0_repeat,F		;　ﾘﾋﾟｰﾄｶｳﾝﾀに保管する
		goto	part0_1			;次の音符に進む

;ﾘﾋﾟｰﾄ1分岐のとき
part0_54	movlw	-1			;ｶｳﾝﾀを
		addwf	part0_repeat,F		;　-1する
		movfw	part0_repeat		;ｶｳﾝﾀが
		andlw	0x0f			;　0に
		btfsc	STATUS,Z		;　なったら
		goto	part0_55		;　飛ぶ
		call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part0_step		;音符ｽﾃｯﾌﾟを保管する
		goto	part0_1			;次の音符に進む
part0_55	incf	part0_step,F		;分岐先ﾃﾞｰﾀを読み飛ばす
		goto	part0_1			;次の音符に進む

;ﾘﾋﾟｰﾄ2回数設定のとき
part0_56	swapf	part0_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを交換しておく
		movlw	0xf0			;古いﾘﾋﾟｰﾄ回数を
		andwf	part0_repeat,F		;　ｸﾘｱしておく
		call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		andlw	0x0f			;ﾘﾋﾟｰﾄ回数を
		iorwf	part0_repeat,F		;　ﾘﾋﾟｰﾄｶｳﾝﾀに保管する
		swapf	part0_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part0_1			;次の音符に進む

;ﾘﾋﾟｰﾄ2分岐のとき
part0_57	swapf	part0_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを交換しておく
		movlw	-1			;ｶｳﾝﾀを
		addwf	part0_repeat,F		;　-1する
		movfw	part0_repeat		;ｶｳﾝﾀが
		andlw	0x0f			;　0に
		btfsc	STATUS,Z		;　なったら
		goto	part0_58		;　飛ぶ
		call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part0_step		;音符ｽﾃｯﾌﾟを保管する
		swapf	part0_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part0_1			;次の音符に進む
part0_58	incf	part0_step,F		;分岐先ﾃﾞｰﾀを読み飛ばす
		swapf	part0_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part0_1			;次の音符に進む

;ﾍﾞﾛｼﾃｨ設定のとき
part0_59	call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part0_velo		;ﾍﾞﾛｼﾃｨ設定値を保管する
		goto	part0_1			;次の音符に進む

;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定のとき
part0_6		call	part0_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part0_enve		;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値を保存する
		goto	part0_1			;次の音符に進む

;直指定音符のとき
part0_61	call	part0_get_onpu		;音価(ｶｳﾝﾄ値)を取得する
		movwf	part0_onka_zan
		call	part0_get_onpu		;音源波形ｻﾝﾌﾟﾙ飛び数を取得する
		movwf	part0_ongen_tobiF
		call	part0_get_onpu
		movwf	part0_ongen_tobiL
		bsf	part0_sts,PART_ON_BIT	;発音音符を表示しておく
		iorwf	part0_ongen_tobiF,W	;音源波形ｻﾝﾌﾟﾙ飛び数が
		btfsc	STATUS,Z		;　0のときは
		bcf	part0_sts,PART_ON_BIT	;　休符を表示する
		goto	part0_3			;音符の演奏に進む

;ﾃﾝﾎﾟ指定のとき
part0_62	call	part0_get_onpu		;ﾃﾝﾎﾟ(音価ﾌﾟﾘｽｹｰﾙ設定値)を取得する
		movwf	onka_psn		;音価ﾌﾟﾘｽｹｰﾙ値に設定する
		goto	part0_1			;次の音符に進む

;ﾀｲ･ｽﾗｰ開始のとき
part0_63	bsf	part0_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ開始を表示
		goto	part0_1

;ﾀｲ･ｽﾗｰ終了のとき
part0_64	bcf	part0_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ終了を表示
		goto	part0_1

;ｴﾝﾍﾞﾛｰﾌﾟ処理の要否ﾁｪｯｸ
part0_7		btfss	part0_sts,PART_ON_BIT	;休符のときは
		goto	part0_999		;　ﾊﾟｰﾄ処理を飛ばす
part0_71	movf	part0_enve,F		;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値が
		btfss	STATUS,Z		;　0でなければ
		goto	part0_72		;　ｴﾝﾍﾞﾛｰﾌﾟ波形処理へ飛ぶ
		movfw	part0_velo		;ﾍﾞﾛｼﾃｨ設定値を
		movwf	part0_velo_enve		;　ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値とする
		goto	part0_8

;ｴﾝﾍﾞﾛｰﾌﾟ処理のﾀｲﾐﾝｸﾞﾁｪｯｸ
part0_72	decfsz	part0_enve_pss,F	;音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part0_8			;　ｴﾝﾍﾞﾛｰﾌﾟ処理を飛ばす
		movfw	part0_enve		;音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part0_enve_pss		;　初期化する
		decfsz	part0_enve_ps,F		;ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part0_8			;　ｴﾝﾍﾞﾛｰﾌﾟ処理を飛ばす
		moviw	HDR_PART0_ENVE_PS[FSR1]	;ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part0_enve_ps		;　初期化する

;ｴﾝﾍﾞﾛｰﾌﾟ値を取得
		btfsc	part0_enve_of,0		;上位7ﾋﾞｯﾄの取得のときは
		goto	part0_74		;　飛ぶ
		lsrf	part0_enve_of,W		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのﾜｰﾄﾞｵﾌｾｯﾄを設定する
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART0_ENVE_H[FSR1]
		movwf	EEADRH
		moviw	HDR_PART0_ENVE_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙのｱﾄﾞﾚｽを加える
		addwf	EEADRL,F
		btfsc	STATUS,C
		incf	EEADRH,F
		incf	EEADRL,F		;ﾃﾞｰﾀ部のｵﾌｾｯﾄを加える
		btfsc	STATUS,Z
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		rlf	EEDATL,W		;下位のb7をCに入れる
		rlf	EEDATH,W		;上位+CをWに入れる
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		andlw	0x7f			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの上位7ﾋﾞｯﾄを
		movwf	part0_enve_h		;　保管しておく
		banksel	EEADRL			;BANK設定
		movfw	EEDATL			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの
		andlw	0x7f			;　下位7ﾋﾞｯﾄを取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		goto	part0_76
part0_74	movfw	part0_enve_h		;保管しておいた上位7ﾋﾞｯﾄを得る

;ｴﾝﾍﾞﾛｰﾌﾟ処理後のﾍﾞﾛｼﾃｨ値を計算
part0_76	movwf	mul_b			;ｴﾝﾍﾞﾛｰﾌﾟ値(7ﾋﾞｯﾄ)と
		movfw	part0_velo
		movwf	mul_a			;　ﾍﾞﾛｼﾃｨ設定値(8ﾋﾞｯﾄ)を
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積15ﾋﾞｯﾄの上位8ﾋﾞｯﾄを
		movwf	part0_velo_enve		;　ｴﾝﾍﾞﾛｰﾌﾟ処理後のﾍﾞﾛｼﾃｨ値とする

;ｴﾝﾍﾞﾛｰﾌﾟ波形を進める
		incf	part0_enve_of,F		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのｵﾌｾｯﾄを進める
		movfw	part0_enve_of		;最後に
		xorwf	part0_enve_n,W		;　なったら
		btfsc	STATUS,Z		;　それ以上
		decf	part0_enve_of,F		;　進めない

;音源ﾃｰﾌﾞﾙ値を取得
part0_8		lsrf	part0_ongen_ofH,W	;音源ﾃｰﾌﾞﾙのｵﾌｾｯﾄを得る
		banksel	EEADRH			;BANK設定
		movwf	EEADRH
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		rrf	part0_ongen_ofL,W
		banksel	EEADRL			;BANK設定
		addlw	WAVE_DATA
		movwf	EEADRL			;波形ﾃﾞｰﾀ部のｵﾌｾｯﾄを加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		moviw	HDR_PART0_ONGEN_L[FSR1]
		addwf	EEADRL,F		;音源ﾃｰﾌﾞﾙのﾎﾟｲﾝﾀ値を加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		moviw	HDR_PART0_ONGEN_H[FSR1]
		addwf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		btfsc	part0_ongen_ofL,0	;ｵﾌｾｯﾄが奇数のときは
		goto	part0_82		;　飛ぶ
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;下位7ﾋﾞｯﾄを取得する
		goto	part0_84
part0_82
		banksel	EEDATL			;BANK設定
		rlf	EEDATL,W		;上位7ﾋﾞｯﾄを取得する
		rlf	EEDATH,W
part0_84	andlw	0x7f

;ｴﾝﾍﾞﾛｰﾌﾟ処理後の出力値を計算
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	mul_b			;音源ﾃﾞｰﾀ値(7ﾋﾞｯﾄ)と
		movfw	part0_velo_enve		;　ｴﾝﾍﾞﾛｰﾌﾟ処理後の
		movwf	mul_a			;　ﾍﾞﾛｼﾃｨ値(8ﾋﾞｯﾄ)を
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積15ﾋﾞｯﾄの上位8ﾋﾞｯﾄを
		addwf	song_out,W		;　演奏出力値に加算する
		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
		movlw	255			;　最大値に
		movwf	song_out		;　抑え込む

;音源ﾃｰﾌﾞﾙを進める
		movfw	part0_ongen_tobiF	;音源ﾃｰﾌﾞﾙ(1/256)のｵﾌｾｯﾄを進める
		addwf	part0_ongen_ofF,F
		btfsc	STATUS,C		;桁上がりしなかったら
		incfsz	part0_ongen_ofL,F	;下位を+1する
		decf	part0_ongen_ofH,F	;下位が桁上がりしたら
		incf	part0_ongen_ofH,F	;　上位を+1する
		movfw	part0_ongen_tobiL	;下位を
		addwf	part0_ongen_ofL,F	;　進める
		btfsc	STATUS,C		;桁上がりしたら
		incf	part0_ongen_ofH,F	;　上位を+1する

;音源ﾃｰﾌﾞﾙを超えたかﾁｪｯｸ
		movfw	part0_ongen_nH		;ｻﾝﾌﾟﾙ数を
		subwf	part0_ongen_ofH,W	;　上位が
		btfss	STATUS,C		;　超えていなければ
		goto	part0_88		;　飛ぶ
		btfss	STATUS,Z		;上位が超えていれば
		goto	part0_86		;　飛ぶ
		movfw	part0_ongen_nL		;上位が同じで
		subwf	part0_ongen_ofL,W	;　下位が
		btfss	STATUS,C		;　超えていなければ
		goto	part0_88		;　飛ぶ
		movfw	part0_ongen_nF		;下位が同じで
		subwf	part0_ongen_ofF,W	;　1/256桁が
		btfss	STATUS,C		;　超えていなければ
		goto	part0_88		;　飛ぶ

;音源ﾃｰﾌﾞﾙを巻戻す
part0_86	movfw	part0_ongen_nF		;1/256桁を
		subwf	part0_ongen_ofF,F	;　巻戻す
		btfss	STATUS,C		;桁下がりしたら
		decfsz	part0_ongen_ofL,F	;桁下がりした
		incf	part0_ongen_ofL,F	;桁下がりした
		decf	part0_ongen_ofL,F	;　下位を-1する
		movfw	part0_ongen_nL		;下位を
		subwf	part0_ongen_ofL,F	;　巻戻す
		btfss	STATUS,C		;桁下がりしたら
		decf	part0_ongen_ofH,F	;　上位を-1する
		movfw	part0_ongen_nH		;上位を
		subwf	part0_ongen_ofH,F	;　巻戻す
part0_88

#if PITCH_N>0
;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理の要否ﾁｪｯｸ
		movf	part0_pitch,F		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値が
		btfsc	STATUS,Z		;　0のときは
		goto	part0_999		;　ﾊﾟｰﾄ処理を飛ばす

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理のﾀｲﾐﾝｸﾞﾁｪｯｸ
		decfsz	part0_pitch_pss,F	;音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part0_999		;　ﾊﾟｰﾄ処理を飛ばす
		movfw	part0_pitch		;音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part0_pitch_pss		;　初期化する
		decfsz	part0_pitch_ps,F	;ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part0_999		;　ﾊﾟｰﾄ処理を飛ばす
		moviw	HDR_PART0_PITCH_PS[FSR1];ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part0_pitch_ps		;　初期化する

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ値を取得
		btfsc	part0_pitch_of,0	;上位7ﾋﾞｯﾄの取得のときは
		goto	part0_94		;　飛ぶ
		lsrf	part0_pitch_of,W	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのﾜｰﾄﾞｵﾌｾｯﾄを設定する
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART0_PITCH_H[FSR1]
		movwf	EEADRH
		moviw	HDR_PART0_PITCH_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙのｱﾄﾞﾚｽを加える
		addwf	EEADRL,F
		btfsc	STATUS,C
		incf	EEADRH,F
		incf	EEADRL,F		;ﾃﾞｰﾀ部のｵﾌｾｯﾄを加える
		btfsc	STATUS,Z
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		rlf	EEDATL,W		;下位のb7をCに入れる
		rlf	EEDATH,W		;上位+CをWに入れる
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		andlw	0x7f			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの上位7ﾋﾞｯﾄを
		movwf	part0_pitch_h		;　保管しておく
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの
		andlw	0x7f			;　下位7ﾋﾞｯﾄを取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		goto	part0_96
part0_94	movfw	part0_pitch_h		;保管しておいた上位7ﾋﾞｯﾄを得る

;ﾋﾟｯﾁﾍﾞﾝﾄﾞを実行
part0_96	addlw	192
		btfsc	STATUS,C
		goto	part0_98
		addlw	-192
		addwf	part0_ongen_tobiF,F	;音源ﾃｰﾌﾞﾙのｻﾝﾌﾟﾙ飛び数を増加する
		btfsc	STATUS,C
		incf	part0_ongen_tobiL,F
		goto	part0_99
part0_98	addlw	-64
		addwf	part0_ongen_tobiF,F	;音源ﾃｰﾌﾞﾙのｻﾝﾌﾟﾙ飛び数を減少する
		btfss	STATUS,C
		decf	part0_ongen_tobiL,F

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃｰﾌﾞﾙを進める
part0_99	incf	part0_pitch_of,F	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのｵﾌｾｯﾄを進める
		movfw	part0_pitch_of		;最後に
		xorwf	part0_pitch_n,W		;　なったら
		btfsc	STATUS,Z		;　それ以上
		decf	part0_pitch_of,F	;　進めない
#endif
part0_999


#if PART_N>1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾟｰﾄ1演奏処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		movlw	-2
		addwf	part_su,W
		btfsc	STATUS,C	
		btfss	song_sts,STS_PART1_BIT	;演奏終了していたら
		goto	part1_999		;　ﾊﾟｰﾄ処理を飛ばす

;演奏中ｽﾃｯﾌﾟの音価ｶｳﾝﾄ残をﾁｪｯｸ
		btfss	song_sts,ONKA_FULL_BIT	;音価ﾌﾟﾘｽｹｰﾗがﾌﾙでなかったら
		goto	part1_7			;　音価残のﾁｪｯｸを飛ばす
		decfsz	part1_onka_zan,F	;音価ｶｳﾝﾄ残を-1して残があれば
		goto	part1_7			;　ｴﾝﾍﾞﾛｰﾌﾟ処理へ飛ぶ

;次の音符に進む
part1_1		call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part1_onpu		;音符ｺｰﾄﾞを保存する
		
;音価ｶｳﾝﾄを取出す
		swapf	part1_onpu,F		;音符ﾃﾞｰﾀから
		rrf	part1_onpu,W		;　音価ｺｰﾄﾞを
		swapf	part1_onpu,F		;　取出す
		andlw	0x07			;音価ｺｰﾄﾞが
		btfsc	STATUS,Z		;　0のときは
		goto	part1_5			;　終了か修飾処理へ飛ぶ
		movwf	FSR0L			;音価ﾃｰﾌﾞﾙｴﾝﾄﾘの
		moviw	HDR_PART1_ONKA_H[FSR1]	;　ｱﾄﾞﾚｽを
		movwf	FSR0H			;　計算する
		moviw	HDR_PART1_ONKA_L[FSR1]
		addwf	FSR0L,F
		btfsc	STATUS,C
		incf	FSR0H,F
		moviw	-1[FSR0]		;音価ｶｳﾝﾄを
		movwf	part1_onka_zan		;　取得する

;休符/発音音符ﾁｪｯｸ
		movfw	part1_onpu		;音符ﾃﾞｰﾀの
		andlw	0x1f			;　音高ｺｰﾄﾞが
		btfsc	STATUS,Z		;　0のときは
		goto	part1_4			;　休符処理へ飛ぶ
		bsf	part1_sts,PART_ON_BIT	;発音音符を表示する

;音高ｺｰﾄﾞから音源波形ｻﾝﾌﾟﾙ飛び数を取出す
		addlw	-1			;音高ｺｰﾄﾞ-1を音高ﾃｰﾌﾞﾙのｵﾌｾｯﾄ値とする
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART1_ONKOU_H[FSR1]	;音高ﾃｰﾌﾞﾙのｱﾄﾞﾚｽを取得する
		movwf	EEADRH
		moviw	HDR_PART1_ONKOU_L[FSR1]
		addwf	EEADRL,F		;音高ﾃｰﾌﾞﾙのｵﾌｾｯﾄ値に加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		movfw	EEDATL			;音源波形ｻﾝﾌﾟﾙ飛び数を取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	part1_ongen_tobiF
		banksel	EEDATH			;BANK設定
		movfw	EEDATH
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	part1_ongen_tobiL

;音符の属性を初期化する
part1_3		btfsc	part1_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ演奏のときは
		goto	part1_71		;　飛ぶ
		clrf	part1_enve_ps		;ｴﾝﾍﾞﾛｰﾌﾟ処理を
		bsf	part1_enve_ps,0		;　初期化する
		clrf	part1_enve_pss
		bsf	part1_enve_pss,0
		clrf	part1_enve_of
#if PITCH_N>1
		clrf	part1_pitch_ps		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理を
		bsf	part1_pitch_ps,0	;　初期化する
		clrf	part1_pitch_pss
		bsf	part1_pitch_pss,0
		clrf	part1_pitch_of
#endif
		goto	part1_71		;ｴﾝﾍﾞﾛｰﾌﾟ処理へ飛ぶ

;休符のとき
part1_4		bcf	part1_sts,PART_ON_BIT	;休符を表示する
		clrf	part1_velo_enve		;ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値を0にする
		goto	part1_999		;ﾊﾟｰﾄ処理を飛ばす

;終了か修飾のとき
part1_5		movfw	part1_onpu		;修飾ｺｰﾄﾞで
		brw				;　分岐する
		goto	part1_51		;終了のとき
		goto	part1_52		;無条件分岐のとき
		goto	part1_53		;ﾘﾋﾟｰﾄ1回数設定のとき
		goto	part1_54		;ﾘﾋﾟｰﾄ1分岐のとき
		goto	part1_56		;ﾘﾋﾟｰﾄ2回数設定のとき
		goto	part1_57		;ﾘﾋﾟｰﾄ2分岐のとき
		goto	part1_59		;ﾍﾞﾛｼﾃｨ設定のとき
		goto	part1_6			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定のとき
		goto	part1_61		;直指定音符のとき
		goto	part1_62		;ﾃﾝﾎﾟ指定のとき
		goto	part1_63		;ﾀｲ･ｽﾗｰ開始のとき
		goto	part1_64		;ﾀｲ･ｽﾗｰ終了のとき

;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定のとき
		call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
#if PITCH_N>1
		movwf	part1_pitch		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値を保存する
#endif
		goto	part1_1			;次の音符に進む

;終了のとき
part1_51	bcf	song_sts,STS_PART1_BIT	;演奏終了にする
		goto	part1_999		;ﾊﾟｰﾄ処理を飛ばす

;無条件分岐のとき
part1_52	call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part1_step		;音符ｽﾃｯﾌﾟを保管する
		goto	part1_1			;次の音符に進む

;ﾘﾋﾟｰﾄ1回数設定のとき
part1_53	movlw	0xf0			;古いﾘﾋﾟｰﾄ回数を
		andwf	part1_repeat,F		;　ｸﾘｱしておく
		call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		andlw	0x0f			;ﾘﾋﾟｰﾄ回数を
		iorwf	part1_repeat,F		;　ﾘﾋﾟｰﾄｶｳﾝﾀに保管する
		goto	part1_1			;次の音符に進む

;ﾘﾋﾟｰﾄ1分岐のとき
part1_54	movlw	-1			;ｶｳﾝﾀを
		addwf	part1_repeat,F		;　-1する
		movfw	part1_repeat		;ｶｳﾝﾀが
		andlw	0x0f			;　0に
		btfsc	STATUS,Z		;　なったら
		goto	part1_55		;　飛ぶ
		call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part1_step		;音符ｽﾃｯﾌﾟを保管する
		goto	part1_1			;次の音符に進む
part1_55	incf	part1_step,F		;分岐先ﾃﾞｰﾀを読み飛ばす
		goto	part1_1			;次の音符に進む

;ﾘﾋﾟｰﾄ2回数設定のとき
part1_56	swapf	part1_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを交換しておく
		movlw	0xf0			;古いﾘﾋﾟｰﾄ回数を
		andwf	part1_repeat,F		;　ｸﾘｱしておく
		call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		andlw	0x0f			;ﾘﾋﾟｰﾄ回数を
		iorwf	part1_repeat,F		;　ﾘﾋﾟｰﾄｶｳﾝﾀに保管する
		swapf	part1_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part1_1			;次の音符に進む

;ﾘﾋﾟｰﾄ2分岐のとき
part1_57	swapf	part1_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを交換しておく
		movlw	-1			;ｶｳﾝﾀを
		addwf	part1_repeat,F		;　-1する
		movfw	part1_repeat		;ｶｳﾝﾀが
		andlw	0x0f			;　0に
		btfsc	STATUS,Z		;　なったら
		goto	part1_58		;　飛ぶ
		call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part1_step		;音符ｽﾃｯﾌﾟを保管する
		swapf	part1_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part1_1			;次の音符に進む
part1_58	incf	part1_step,F		;分岐先ﾃﾞｰﾀを読み飛ばす
		swapf	part1_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part1_1			;次の音符に進む

;ﾍﾞﾛｼﾃｨ設定のとき
part1_59	call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part1_velo		;ﾍﾞﾛｼﾃｨ設定値を保管する
		goto	part1_1			;次の音符に進む

;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定のとき
part1_6		call	part1_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part1_enve		;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値を保存する
		goto	part1_1			;次の音符に進む

;直指定音符のとき
part1_61	call	part1_get_onpu		;音価(ｶｳﾝﾄ値)を取得する
		movwf	part1_onka_zan
		call	part1_get_onpu		;音源波形ｻﾝﾌﾟﾙ飛び数を取得する
		movwf	part1_ongen_tobiF
		call	part1_get_onpu
		movwf	part1_ongen_tobiL
		bsf	part1_sts,PART_ON_BIT	;発音音符を表示しておく
		iorwf	part1_ongen_tobiF,W	;音源波形ｻﾝﾌﾟﾙ飛び数が
		btfsc	STATUS,Z		;　0のときは
		bcf	part1_sts,PART_ON_BIT	;　休符を表示する
		goto	part1_3			;音符の演奏に進む

;ﾃﾝﾎﾟ指定のとき
part1_62	call	part1_get_onpu		;ﾃﾝﾎﾟ(音価ﾌﾟﾘｽｹｰﾙ設定値)を取得する
		movwf	onka_psn		;音価ﾌﾟﾘｽｹｰﾙ値に設定する
		goto	part1_1			;次の音符に進む

;ﾀｲ･ｽﾗｰ開始のとき
part1_63	bsf	part1_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ開始を表示
		goto	part1_1

;ﾀｲ･ｽﾗｰ終了のとき
part1_64	bcf	part1_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ終了を表示
		goto	part1_1

;ｴﾝﾍﾞﾛｰﾌﾟ処理の要否ﾁｪｯｸ
part1_7		btfss	part1_sts,PART_ON_BIT	;休符のときは
		goto	part1_999		;　ﾊﾟｰﾄ処理を飛ばす
part1_71	movf	part1_enve,F		;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値が
		btfss	STATUS,Z		;　0でなければ
		goto	part1_72		;　ｴﾝﾍﾞﾛｰﾌﾟ波形処理へ飛ぶ
		movfw	part1_velo		;ﾍﾞﾛｼﾃｨ設定値を
		movwf	part1_velo_enve		;　ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値とする
		goto	part1_8

;ｴﾝﾍﾞﾛｰﾌﾟ処理のﾀｲﾐﾝｸﾞﾁｪｯｸ
part1_72	decfsz	part1_enve_pss,F	;音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part1_8			;　ｴﾝﾍﾞﾛｰﾌﾟ処理を飛ばす
		movfw	part1_enve		;音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part1_enve_pss		;　初期化する
		decfsz	part1_enve_ps,F		;ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part1_8			;　ｴﾝﾍﾞﾛｰﾌﾟ処理を飛ばす
		moviw	HDR_PART1_ENVE_PS[FSR1]	;ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part1_enve_ps		;　初期化する

;ｴﾝﾍﾞﾛｰﾌﾟ値を取得
		btfsc	part1_enve_of,0		;上位7ﾋﾞｯﾄの取得のときは
		goto	part1_74		;　飛ぶ
		lsrf	part1_enve_of,W		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのﾜｰﾄﾞｵﾌｾｯﾄを設定する
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART1_ENVE_H[FSR1]
		movwf	EEADRH
		moviw	HDR_PART1_ENVE_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙのｱﾄﾞﾚｽを加える
		addwf	EEADRL,F
		btfsc	STATUS,C
		incf	EEADRH,F
		incf	EEADRL,F		;ﾃﾞｰﾀ部のｵﾌｾｯﾄを加える
		btfsc	STATUS,Z
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		rlf	EEDATL,W		;下位のb7をCに入れる
		rlf	EEDATH,W		;上位+CをWに入れる
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		andlw	0x7f			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの上位7ﾋﾞｯﾄを
		movwf	part1_enve_h		;　保管しておく
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの
		andlw	0x7f			;　下位7ﾋﾞｯﾄを取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		goto	part1_76
part1_74	movfw	part1_enve_h		;保管しておいた上位7ﾋﾞｯﾄを得る

;ｴﾝﾍﾞﾛｰﾌﾟ処理後のﾍﾞﾛｼﾃｨ値を計算
part1_76	movwf	mul_b			;ｴﾝﾍﾞﾛｰﾌﾟ値(7ﾋﾞｯﾄ)と
		movfw	part1_velo
		movwf	mul_a			;　ﾍﾞﾛｼﾃｨ設定値(8ﾋﾞｯﾄ)を
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積15ﾋﾞｯﾄの上位8ﾋﾞｯﾄを
		movwf	part1_velo_enve		;　ｴﾝﾍﾞﾛｰﾌﾟ処理後のﾍﾞﾛｼﾃｨ値とする

;ｴﾝﾍﾞﾛｰﾌﾟ波形を進める
		incf	part1_enve_of,F		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのｵﾌｾｯﾄを進める
		movfw	part1_enve_of		;最後に
		xorwf	part1_enve_n,W		;　なったら
		btfsc	STATUS,Z		;　それ以上
		decf	part1_enve_of,F		;　進めない

;音源ﾃｰﾌﾞﾙ値を取得
part1_8		lsrf	part1_ongen_ofH,W	;音源ﾃｰﾌﾞﾙのｵﾌｾｯﾄを得る
		banksel	EEADRH			;BANK設定
		movwf	EEADRH
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		rrf	part1_ongen_ofL,W
		banksel	EEADRL			;BANK設定
		addlw	WAVE_DATA
		movwf	EEADRL			;波形ﾃﾞｰﾀ部のｵﾌｾｯﾄを加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		moviw	HDR_PART1_ONGEN_L[FSR1]
		addwf	EEADRL,F		;音源ﾃｰﾌﾞﾙのﾎﾟｲﾝﾀ値を加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		moviw	HDR_PART1_ONGEN_H[FSR1]
		addwf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		btfsc	part1_ongen_ofL,0	;ｵﾌｾｯﾄが奇数のときは
		goto	part1_82		;　飛ぶ
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;下位7ﾋﾞｯﾄを取得する
		goto	part1_84
part1_82
		banksel	EEDATL			;BANK設定
		rlf	EEDATL,W		;上位7ﾋﾞｯﾄを取得する
		rlf	EEDATH,W
part1_84	andlw	0x7f

;ｴﾝﾍﾞﾛｰﾌﾟ処理後の出力値を計算
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	mul_b			;音源ﾃﾞｰﾀ値(7ﾋﾞｯﾄ)と
		movfw	part1_velo_enve		;　ｴﾝﾍﾞﾛｰﾌﾟ処理後の
		movwf	mul_a			;　ﾍﾞﾛｼﾃｨ値(8ﾋﾞｯﾄ)を
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積15ﾋﾞｯﾄの上位8ﾋﾞｯﾄを
		addwf	song_out,W		;　演奏出力値に加算する
		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
		movlw	255			;　最大値に
		movwf	song_out		;　抑え込む

;音源ﾃｰﾌﾞﾙを進める
		movfw	part1_ongen_tobiF	;音源ﾃｰﾌﾞﾙ(1/256)のｵﾌｾｯﾄを進める
		addwf	part1_ongen_ofF,F
		btfsc	STATUS,C		;桁上がりしなかったら
		incfsz	part1_ongen_ofL,F	;下位を+1する
		decf	part1_ongen_ofH,F	;下位が桁上がりしたら
		incf	part1_ongen_ofH,F	;　上位を+1する
		movfw	part1_ongen_tobiL	;下位を
		addwf	part1_ongen_ofL,F	;　進める
		btfsc	STATUS,C		;桁上がりしたら
		incf	part1_ongen_ofH,F	;　上位を+1する

;音源ﾃｰﾌﾞﾙを超えたかﾁｪｯｸ
		movfw	part1_ongen_nH		;ｻﾝﾌﾟﾙ数を
		subwf	part1_ongen_ofH,W	;　上位が
		btfss	STATUS,C		;　超えていなければ
		goto	part1_88		;　飛ぶ
		btfss	STATUS,Z		;上位が超えていれば
		goto	part1_86		;　飛ぶ
		movfw	part1_ongen_nL		;上位が同じで
		subwf	part1_ongen_ofL,W	;　下位が
		btfss	STATUS,C		;　超えていなければ
		goto	part1_88		;　飛ぶ
		movfw	part1_ongen_nF		;下位が同じで
		subwf	part1_ongen_ofF,W	;　1/256桁が
		btfss	STATUS,C		;　超えていなければ
		goto	part1_88		;　飛ぶ

;音源ﾃｰﾌﾞﾙを巻戻す
part1_86	movfw	part1_ongen_nF		;1/256桁を
		subwf	part1_ongen_ofF,F	;　巻戻す
		btfss	STATUS,C		;桁下がりしたら
		decfsz	part1_ongen_ofL,F	;桁下がりした
		incf	part1_ongen_ofL,F	;桁下がりした
		decf	part1_ongen_ofL,F	;　下位を-1する
		movfw	part1_ongen_nL		;下位を
		subwf	part1_ongen_ofL,F	;　巻戻す
		btfss	STATUS,C		;桁下がりしたら
		decf	part1_ongen_ofH,F	;　上位を-1する
		movfw	part1_ongen_nH		;上位を
		subwf	part1_ongen_ofH,F	;　巻戻す
part1_88

#if PITCH_N>1
;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理の要否ﾁｪｯｸ
		movf	part1_pitch,F		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値が
		btfsc	STATUS,Z		;　0のときは
		goto	part1_999		;　ﾊﾟｰﾄ処理を飛ばす

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理のﾀｲﾐﾝｸﾞﾁｪｯｸ
		decfsz	part1_pitch_pss,F	;音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part1_999		;　ﾊﾟｰﾄ処理を飛ばす
		movfw	part1_pitch		;音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part1_pitch_pss		;　初期化する
		decfsz	part1_pitch_ps,F	;ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part1_999		;　ﾊﾟｰﾄ処理を飛ばす
		moviw	HDR_PART1_PITCH_PS[FSR1];ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part1_pitch_ps		;　初期化する

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ値を取得
		btfsc	part1_pitch_of,0	;上位7ﾋﾞｯﾄの取得のときは
		goto	part1_94		;　飛ぶ
		lsrf	part1_pitch_of,W	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのﾜｰﾄﾞｵﾌｾｯﾄを設定する
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART1_PITCH_H[FSR1]
		movwf	EEADRH
		moviw	HDR_PART1_PITCH_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙのｱﾄﾞﾚｽを加える
		addwf	EEADRL,F
		btfsc	STATUS,C
		incf	EEADRH,F
		incf	EEADRL,F		;ﾃﾞｰﾀ部のｵﾌｾｯﾄを加える
		btfsc	STATUS,Z
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		rlf	EEDATL,W		;下位のb7をCに入れる
		rlf	EEDATH,W		;上位+CをWに入れる
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		andlw	0x7f			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの上位7ﾋﾞｯﾄを
		movwf	part1_pitch_h		;　保管しておく
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの
		andlw	0x7f			;　下位7ﾋﾞｯﾄを取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		goto	part1_96
part1_94	movfw	part1_pitch_h		;保管しておいた上位7ﾋﾞｯﾄを得る

;ﾋﾟｯﾁﾍﾞﾝﾄﾞを実行
part1_96	addlw	192
		btfsc	STATUS,C
		goto	part1_98
		addlw	-192
		addwf	part1_ongen_tobiF,F	;音源ﾃｰﾌﾞﾙのｻﾝﾌﾟﾙ飛び数を増加する
		btfsc	STATUS,C
		incf	part1_ongen_tobiL,F
		goto	part1_99
part1_98	addlw	-64
		addwf	part1_ongen_tobiF,F	;音源ﾃｰﾌﾞﾙのｻﾝﾌﾟﾙ飛び数を減少する
		btfss	STATUS,C
		decf	part1_ongen_tobiL,F

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃｰﾌﾞﾙを進める
part1_99	incf	part1_pitch_of,F	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのｵﾌｾｯﾄを進める
		movfw	part1_pitch_of		;最後に
		xorwf	part1_pitch_n,W		;　なったら
		btfsc	STATUS,Z		;　それ以上
		decf	part1_pitch_of,F	;　進めない
#endif
part1_999
#endif


#if PART_N>2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ﾊﾟｰﾄ2演奏処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		movlw	-3
		addwf	part_su,W
		btfsc	STATUS,C	
		btfss	song_sts,STS_PART2_BIT	;演奏終了していたら
		goto	part2_999		;　ﾊﾟｰﾄ処理を飛ばす

;演奏中ｽﾃｯﾌﾟの音価ｶｳﾝﾄ残をﾁｪｯｸ
		btfss	song_sts,ONKA_FULL_BIT	;音価ﾌﾟﾘｽｹｰﾗがﾌﾙでなかったら
		goto	part2_7			;　音価残のﾁｪｯｸを飛ばす
		decfsz	part2_onka_zan,F	;音価ｶｳﾝﾄ残を-1して残があれば
		goto	part2_7			;　ｴﾝﾍﾞﾛｰﾌﾟ処理へ飛ぶ

;次の音符に進む
part2_1		call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part2_onpu		;音符ｺｰﾄﾞを保存する
		
;音価ｶｳﾝﾄを取出す
		swapf	part2_onpu,F		;音符ﾃﾞｰﾀから
		rrf	part2_onpu,W		;　音価ｺｰﾄﾞを
		swapf	part2_onpu,F		;　取出す
		andlw	0x07			;音価ｺｰﾄﾞが
		btfsc	STATUS,Z		;　0のときは
		goto	part2_5			;　終了か修飾処理へ飛ぶ
		movwf	FSR0L			;音価ﾃｰﾌﾞﾙｴﾝﾄﾘの
		moviw	HDR_PART2_ONKA_H[FSR1]	;　ｱﾄﾞﾚｽを
		movwf	FSR0H			;　計算する
		moviw	HDR_PART2_ONKA_L[FSR1]
		addwf	FSR0L,F
		btfsc	STATUS,C
		incf	FSR0H,F
		moviw	-1[FSR0]		;音価ｶｳﾝﾄを
		movwf	part2_onka_zan		;　取得する

;休符/発音音符ﾁｪｯｸ
		movfw	part2_onpu		;音符ﾃﾞｰﾀの
		andlw	0x1f			;　音高ｺｰﾄﾞが
		btfsc	STATUS,Z		;　0のときは
		goto	part2_4			;　休符処理へ飛ぶ
		bsf	part2_sts,PART_ON_BIT	;発音音符を表示する

;音高ｺｰﾄﾞから音源波形ｻﾝﾌﾟﾙ飛び数を取出す
		addlw	-1			;音高ｺｰﾄﾞ-1を音高ﾃｰﾌﾞﾙのｵﾌｾｯﾄ値とする
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART2_ONKOU_H[FSR1]	;音高ﾃｰﾌﾞﾙのｱﾄﾞﾚｽを取得する
		movwf	EEADRH
		moviw	HDR_PART2_ONKOU_L[FSR1]
		addwf	EEADRL,F		;音高ﾃｰﾌﾞﾙのｵﾌｾｯﾄ値に加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		movfw	EEDATL			;音源波形ｻﾝﾌﾟﾙ飛び数を取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	part2_ongen_tobiF
		banksel	EEDATH			;BANK設定
		movfw	EEDATH
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	part2_ongen_tobiL

;音符の属性を初期化する
part2_3		btfsc	part2_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ演奏のときは
		goto	part2_71		;　飛ぶ
		clrf	part2_enve_ps		;ｴﾝﾍﾞﾛｰﾌﾟ処理を
		bsf	part2_enve_ps,0		;　初期化する
		clrf	part2_enve_pss
		bsf	part2_enve_pss,0
		clrf	part2_enve_of
#if PITCH_N>2
		clrf	part2_pitch_ps		;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理を
		bsf	part2_pitch_ps,0	;　初期化する
		clrf	part2_pitch_pss
		bsf	part2_pitch_pss,0
		clrf	part2_pitch_of
#endif
		goto	part2_71		;ｴﾝﾍﾞﾛｰﾌﾟ処理へ飛ぶ

;休符のとき
part2_4		bcf	part2_sts,PART_ON_BIT	;休符を表示する
		clrf	part2_velo_enve		;ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値を0にする
		goto	part2_999		;ﾊﾟｰﾄ処理を飛ばす

;終了か修飾のとき
part2_5		movfw	part2_onpu		;修飾ｺｰﾄﾞで
		brw				;　分岐する
		goto	part2_51		;終了のとき
		goto	part2_52		;無条件分岐のとき
		goto	part2_53		;ﾘﾋﾟｰﾄ1回数設定のとき
		goto	part2_54		;ﾘﾋﾟｰﾄ1分岐のとき
		goto	part2_56		;ﾘﾋﾟｰﾄ2回数設定のとき
		goto	part2_57		;ﾘﾋﾟｰﾄ2分岐のとき
		goto	part2_59		;ﾍﾞﾛｼﾃｨ設定のとき
		goto	part2_6			;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定のとき
		goto	part2_61		;直指定音符のとき
		goto	part2_62		;ﾃﾝﾎﾟ指定のとき
		goto	part2_63		;ﾀｲ･ｽﾗｰ開始のとき
		goto	part2_64		;ﾀｲ･ｽﾗｰ終了のとき

;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定のとき
		call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
#if PITCH_N>2
		movwf	part2_pitch		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値を保存する
#endif
		goto	part2_1			;次の音符に進む

;終了のとき
part2_51	bcf	song_sts,STS_PART2_BIT	;演奏終了にする
		goto	part2_999		;ﾊﾟｰﾄ処理を飛ばす

;無条件分岐のとき
part2_52	call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part2_step		;音符ｽﾃｯﾌﾟを保管する
		goto	part2_1			;次の音符に進む

;ﾘﾋﾟｰﾄ1回数設定のとき
part2_53	movlw	0xf0			;古いﾘﾋﾟｰﾄ回数を
		andwf	part2_repeat,F		;　ｸﾘｱしておく
		call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		andlw	0x0f			;ﾘﾋﾟｰﾄ回数を
		iorwf	part2_repeat,F		;　ﾘﾋﾟｰﾄｶｳﾝﾀに保管する
		goto	part2_1			;次の音符に進む

;ﾘﾋﾟｰﾄ1分岐のとき
part2_54	movlw	-1			;ｶｳﾝﾀを
		addwf	part2_repeat,F		;　-1する
		movfw	part2_repeat		;ｶｳﾝﾀが
		andlw	0x0f			;　0に
		btfsc	STATUS,Z		;　なったら
		goto	part2_55		;　飛ぶ
		call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part2_step		;音符ｽﾃｯﾌﾟを保管する
		goto	part2_1			;次の音符に進む
part2_55	incf	part2_step,F		;分岐先ﾃﾞｰﾀを読み飛ばす
		goto	part2_1			;次の音符に進む

;ﾘﾋﾟｰﾄ2回数設定のとき
part2_56	swapf	part2_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを交換しておく
		movlw	0xf0			;古いﾘﾋﾟｰﾄ回数を
		andwf	part2_repeat,F		;　ｸﾘｱしておく
		call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		andlw	0x0f			;ﾘﾋﾟｰﾄ回数を
		iorwf	part2_repeat,F		;　ﾘﾋﾟｰﾄｶｳﾝﾀに保管する
		swapf	part2_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part2_1			;次の音符に進む

;ﾘﾋﾟｰﾄ2分岐のとき
part2_57	swapf	part2_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを交換しておく
		movlw	-1			;ｶｳﾝﾀを
		addwf	part2_repeat,F		;　-1する
		movfw	part2_repeat		;ｶｳﾝﾀが
		andlw	0x0f			;　0に
		btfsc	STATUS,Z		;　なったら
		goto	part2_58		;　飛ぶ
		call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part2_step		;音符ｽﾃｯﾌﾟを保管する
		swapf	part2_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part2_1			;次の音符に進む
part2_58	incf	part2_step,F		;分岐先ﾃﾞｰﾀを読み飛ばす
		swapf	part2_repeat,F		;ﾘﾋﾟｰﾄｶｳﾝﾀのﾆﾌﾞﾙを元に戻す
		goto	part2_1			;次の音符に進む

;ﾍﾞﾛｼﾃｨ設定のとき
part2_59	call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part2_velo		;ﾍﾞﾛｼﾃｨ設定値を保管する
		goto	part2_1			;次の音符に進む

;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定のとき
part2_6		call	part2_get_onpu		;音符ﾃﾞｰﾀを取得する
		movwf	part2_enve		;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値を保存する
		goto	part2_1			;次の音符に進む

;直指定音符のとき
part2_61	call	part2_get_onpu		;音価(ｶｳﾝﾄ値)を取得する
		movwf	part2_onka_zan
		call	part2_get_onpu		;音源波形ｻﾝﾌﾟﾙ飛び数を取得する
		movwf	part2_ongen_tobiF
		call	part2_get_onpu
		movwf	part2_ongen_tobiL
		bsf	part2_sts,PART_ON_BIT	;発音音符を表示しておく
		iorwf	part2_ongen_tobiF,W	;音源波形ｻﾝﾌﾟﾙ飛び数が
		btfsc	STATUS,Z		;　0のときは
		bcf	part2_sts,PART_ON_BIT	;　休符を表示する
		goto	part2_3			;音符の演奏に進む

;ﾃﾝﾎﾟ指定のとき
part2_62	call	part2_get_onpu		;ﾃﾝﾎﾟ(音価ﾌﾟﾘｽｹｰﾙ設定値)を取得する
		movwf	onka_psn		;音価ﾌﾟﾘｽｹｰﾙ値に設定する
		goto	part2_1			;次の音符に進む

;ﾀｲ･ｽﾗｰ開始のとき
part2_63	bsf	part2_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ開始を表示
		goto	part2_1

;ﾀｲ･ｽﾗｰ終了のとき
part2_64	bcf	part2_sts,PART_TIE_BIT	;ﾀｲ･ｽﾗｰ終了を表示
		goto	part2_1

;ｴﾝﾍﾞﾛｰﾌﾟ処理の要否ﾁｪｯｸ
part2_7		btfss	part2_sts,PART_ON_BIT	;休符のときは
		goto	part2_999		;　ﾊﾟｰﾄ処理を飛ばす
part2_71	movf	part2_enve,F		;ｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ設定値が
		btfss	STATUS,Z		;　0でなければ
		goto	part2_72		;　ｴﾝﾍﾞﾛｰﾌﾟ波形処理へ飛ぶ
		movfw	part2_velo		;ﾍﾞﾛｼﾃｨ設定値を
		movwf	part2_velo_enve		;　ｴﾝﾍﾞﾛ-ﾌﾟ処理後のﾍﾞﾛｼﾃｨ値とする
		goto	part2_8

;ｴﾝﾍﾞﾛｰﾌﾟ処理のﾀｲﾐﾝｸﾞﾁｪｯｸ
part2_72	decfsz	part2_enve_pss,F	;音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part2_8			;　ｴﾝﾍﾞﾛｰﾌﾟ処理を飛ばす
		movfw	part2_enve		;音符ﾃﾞｰﾀのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part2_enve_pss		;　初期化する
		decfsz	part2_enve_ps,F		;ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part2_8			;　ｴﾝﾍﾞﾛｰﾌﾟ処理を飛ばす
		moviw	HDR_PART2_ENVE_PS[FSR1]	;ｿﾝｸﾞﾍｯﾀﾞのｴﾝﾍﾞﾛｰﾌﾟﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part2_enve_ps		;　初期化する

;ｴﾝﾍﾞﾛｰﾌﾟ値を取得
		btfsc	part2_enve_of,0		;上位7ﾋﾞｯﾄの取得のときは
		goto	part2_74		;　飛ぶ
		lsrf	part2_enve_of,W		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのﾜｰﾄﾞｵﾌｾｯﾄを設定する
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART2_ENVE_H[FSR1]
		movwf	EEADRH
		moviw	HDR_PART2_ENVE_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙのｱﾄﾞﾚｽを加える
		addwf	EEADRL,F
		btfsc	STATUS,C
		incf	EEADRH,F
		incf	EEADRL,F		;ﾃﾞｰﾀ部のｵﾌｾｯﾄを加える
		btfsc	STATUS,Z
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		rlf	EEDATL,W		;下位のb7をCに入れる
		rlf	EEDATH,W		;上位+CをWに入れる
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		andlw	0x7f			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの上位7ﾋﾞｯﾄを
		movwf	part2_enve_h		;　保管しておく
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの
		andlw	0x7f			;　下位7ﾋﾞｯﾄを取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		goto	part2_76
part2_74	movfw	part2_enve_h		;保管しておいた上位7ﾋﾞｯﾄを得る

;ｴﾝﾍﾞﾛｰﾌﾟ処理後のﾍﾞﾛｼﾃｨ値を計算
part2_76	movwf	mul_b			;ｴﾝﾍﾞﾛｰﾌﾟ値(7ﾋﾞｯﾄ)と
		movfw	part2_velo
		movwf	mul_a			;　ﾍﾞﾛｼﾃｨ設定値(8ﾋﾞｯﾄ)を
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積15ﾋﾞｯﾄの上位8ﾋﾞｯﾄを
		movwf	part2_velo_enve		;　ｴﾝﾍﾞﾛｰﾌﾟ処理後のﾍﾞﾛｼﾃｨ値とする

;ｴﾝﾍﾞﾛｰﾌﾟ波形を進める
		incf	part2_enve_of,F		;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのｵﾌｾｯﾄを進める
		movfw	part2_enve_of		;最後に
		xorwf	part2_enve_n,W		;　なったら
		btfsc	STATUS,Z		;　それ以上
		decf	part2_enve_of,F		;　進めない

;音源ﾃｰﾌﾞﾙ値を取得
part2_8		lsrf	part2_ongen_ofH,W	;音源ﾃｰﾌﾞﾙのｵﾌｾｯﾄを得る
		banksel	EEADRH			;BANK設定
		movwf	EEADRH
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		rrf	part2_ongen_ofL,W
		banksel	EEADRL			;BANK設定
		addlw	WAVE_DATA
		movwf	EEADRL			;波形ﾃﾞｰﾀ部のｵﾌｾｯﾄを加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		moviw	HDR_PART2_ONGEN_L[FSR1]
		addwf	EEADRL,F		;音源ﾃｰﾌﾞﾙのﾎﾟｲﾝﾀ値を加算する
		btfsc	STATUS,C
		incf	EEADRH,F
		moviw	HDR_PART2_ONGEN_H[FSR1]
		addwf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		btfsc	part2_ongen_ofL,0	;ｵﾌｾｯﾄが奇数のときは
		goto	part2_82		;　飛ぶ
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;下位7ﾋﾞｯﾄを取得する
		goto	part2_84
part2_82
		banksel	EEDATL			;BANK設定
		rlf	EEDATL,W		;上位7ﾋﾞｯﾄを取得する
		rlf	EEDATH,W
part2_84	andlw	0x7f
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定

;ｴﾝﾍﾞﾛｰﾌﾟ処理後の出力値を計算
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		movwf	mul_b			;音源ﾃﾞｰﾀ値(7ﾋﾞｯﾄ)と
		movfw	part2_velo_enve		;　ｴﾝﾍﾞﾛｰﾌﾟ処理後の
		movwf	mul_a			;　ﾍﾞﾛｼﾃｨ値(8ﾋﾞｯﾄ)を
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積15ﾋﾞｯﾄの上位8ﾋﾞｯﾄを
		addwf	song_out,W		;　演奏出力値に加算する
		btfsc	STATUS,C		;ｵｰﾊﾞﾌﾛｰしたら
		movlw	255			;　最大値に
		movwf	song_out		;　抑え込む

;音源ﾃｰﾌﾞﾙを進める
		movfw	part2_ongen_tobiF	;音源ﾃｰﾌﾞﾙ(1/256)のｵﾌｾｯﾄを進める
		addwf	part2_ongen_ofF,F
		btfsc	STATUS,C		;桁上がりしなかったら
		incfsz	part2_ongen_ofL,F	;下位を+1する
		decf	part2_ongen_ofH,F	;下位が桁上がりしたら
		incf	part2_ongen_ofH,F	;　上位を+1する

		movfw	part2_ongen_tobiL	;下位を
		addwf	part2_ongen_ofL,F	;　進める
		btfsc	STATUS,C		;桁上がりしたら
		incf	part2_ongen_ofH,F	;　上位を+1する

;音源ﾃｰﾌﾞﾙを超えたかﾁｪｯｸ
		movfw	part2_ongen_nH		;ｻﾝﾌﾟﾙ数を
		subwf	part2_ongen_ofH,W	;　上位が
		btfss	STATUS,C		;　超えていなければ
		goto	part2_88		;　飛ぶ
		btfss	STATUS,Z		;上位が超えていれば
		goto	part2_86		;　飛ぶ
		movfw	part2_ongen_nL		;上位が同じで
		subwf	part2_ongen_ofL,W	;　下位が
		btfss	STATUS,C		;　超えていなければ
		goto	part2_88		;　飛ぶ
		movfw	part2_ongen_nF		;下位が同じで
		subwf	part2_ongen_ofF,W	;　1/256桁が
		btfss	STATUS,C		;　超えていなければ
		goto	part2_88		;　飛ぶ

;音源ﾃｰﾌﾞﾙを巻戻す
part2_86	movfw	part2_ongen_nF		;1/256桁を
		subwf	part2_ongen_ofF,F	;　巻戻す
		btfss	STATUS,C		;桁下がりしたら
		decfsz	part2_ongen_ofL,F	;桁下がりした
		incf	part2_ongen_ofL,F	;桁下がりした
		decf	part2_ongen_ofL,F	;　下位を-1する
		movfw	part2_ongen_nL		;下位を
		subwf	part2_ongen_ofL,F	;　巻戻す
		btfss	STATUS,C		;桁下がりしたら
		decf	part2_ongen_ofH,F	;　上位を-1する
		movfw	part2_ongen_nH		;上位を
		subwf	part2_ongen_ofH,F	;　巻戻す
part2_88

#if PITCH_N>2
;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理の要否ﾁｪｯｸ
		movf	part2_pitch,F		;ﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ設定値が
		btfsc	STATUS,Z		;　0のときは
		goto	part2_999		;　ﾊﾟｰﾄ処理を飛ばす

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ処理のﾀｲﾐﾝｸﾞﾁｪｯｸ
		decfsz	part2_pitch_pss,F	;音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part2_999		;　ﾊﾟｰﾄ処理を飛ばす
		movfw	part2_pitch		;音符ﾃﾞｰﾀのﾋﾟｯﾁﾍﾞﾝﾄﾞ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part2_pitch_pss		;　初期化する
		decfsz	part2_pitch_ps,F	;ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗがﾌﾙでなければ
		goto	part2_999		;　ﾊﾟｰﾄ処理を飛ばす
		moviw	HDR_PART2_PITCH_PS[FSR1];ｿﾝｸﾞﾍｯﾀﾞのﾋﾟｯﾁﾍﾞﾝﾄﾞﾀｲﾑ対応のﾌﾟﾘｽｹｰﾗを
		movwf	part2_pitch_ps		;　初期化する

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ値を取得
		btfsc	part2_pitch_of,0	;上位7ﾋﾞｯﾄの取得のときは
		goto	part2_94		;　飛ぶ
		lsrf	part2_pitch_of,W	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのﾜｰﾄﾞｵﾌｾｯﾄを設定する
		banksel	EEADRL			;BANK設定
		movwf	EEADRL
		moviw	HDR_PART2_PITCH_H[FSR1]
		movwf	EEADRH
		moviw	HDR_PART2_PITCH_L[FSR1]	;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙのｱﾄﾞﾚｽを加える
		addwf	EEADRL,F
		btfsc	STATUS,C
		incf	EEADRH,F
		incf	EEADRL,F		;ﾃﾞｰﾀ部のｵﾌｾｯﾄを加える
		btfsc	STATUS,Z
		incf	EEADRH,F
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		rlf	EEDATL,W		;下位のb7をCに入れる
		rlf	EEDATH,W		;上位+CをWに入れる
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		andlw	0x7f			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの上位7ﾋﾞｯﾄを
		movwf	part2_pitch_h		;　保管しておく
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;ｴﾝﾍﾞﾛｰﾌﾟﾃｰﾌﾞﾙの
		andlw	0x7f			;　下位7ﾋﾞｯﾄを取得する
		banksel	ORGEL_BANK		;ｵﾙｺﾞｰﾙ演奏ﾃﾞｰﾀのﾊﾞﾝｸ設定
		goto	part2_96
part2_94	movfw	part2_pitch_h		;保管しておいた上位7ﾋﾞｯﾄを得る

;ﾋﾟｯﾁﾍﾞﾝﾄﾞを実行
part2_96	addlw	192
		btfsc	STATUS,C
		goto	part2_98
		addlw	-192
		addwf	part2_ongen_tobiF,F	;音源ﾃｰﾌﾞﾙのｻﾝﾌﾟﾙ飛び数を増加する
		btfsc	STATUS,C
		incf	part2_ongen_tobiL,F
		goto	part2_99
part2_98	addlw	-64
		addwf	part2_ongen_tobiF,F	;音源ﾃｰﾌﾞﾙのｻﾝﾌﾟﾙ飛び数を減少する
		btfss	STATUS,C
		decf	part2_ongen_tobiL,F

;ﾋﾟｯﾁﾍﾞﾝﾄﾞ波形ﾃｰﾌﾞﾙを進める
part2_99	incf	part2_pitch_of,F	;ｴﾝﾍﾞﾛｰﾌﾟ波形ﾃｰﾌﾞﾙのｵﾌｾｯﾄを進める
		movfw	part2_pitch_of		;最後に
		xorwf	part2_pitch_n,W		;　なったら
		btfsc	STATUS,Z		;　それ以上
		decf	part2_pitch_of,F	;　進めない
#endif
part2_999
#endif
		return
#endif


#if VOICE_N>0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声0選択処理(API関数)
;input
;　W(b7):ﾎﾟｯﾌﾟﾉｲｽﾞ抑止(0=する､1=しないで切れ目なく再生する)
;　W(b5-0):音声番号(0=再生中断､1〜63=指定音声番号を再生開始)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声番号を評価
VOICE0_SEL	movwf	mul_wk			;入力ﾊﾟﾗﾒｰﾀを退避しておく
		xorwf	voice0_no,W		;現在再生中の
		andlw	~VO_STS_MSK		;　音声番号と
		btfsc	STATUS,Z		;　同じだったら
		return				;　無効果で戻る
		xorwf	voice0_no,W		;音声番号を
		andlw	~VO_STS_MSK		;　復元する
		btfss	STATUS,Z		;音声番号が
		goto	voice0_sel5		;　0のときは
		clrf	voice0_no		;　制御ﾌﾗｸﾞと音声番号をｸﾘｱする
		return

;音声番号の実装ﾁｪｯｸ
voice0_sel5	addlw	-((voiceN_tbl_end-voiceN_tbl)/HDR_VOn_size+1)
						;音声番号が実装音声数以内で
		btfsc	STATUS,C		;　なかったら
		return				;　無効果で戻る
		addlw	(voiceN_tbl_end-voiceN_tbl)/HDR_VOn_size+1
						;音声番号を復元する
		movwf	voice0_no		;音声番号を記憶しておく

;音声ﾃﾞｰﾀｲﾝﾃﾞｯｸｽを取得
		movfw	BSR			;BSRを
		movwf	api_bsr			;　退避する
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		movlw	high(voiceN_tbl)	;音声ｲﾝﾃﾞｯｸｽｱﾄﾞﾚｽの
		movwf	FSR0H			;　上位桁を設定する
		decf	voice0_no,W		;音声番号-1がｴﾝﾄﾘ番号
		movwf	FSR0L			;ｴﾝﾄﾘ番号*5が
		lslf	FSR0L,F			;　ｲﾝﾃﾞｯｸｽのｵﾌｾｯﾄになる
		lslf	FSR0L,F
		addwf	FSR0L,F
		movlw	0			;上位桁への
		addwfc	FSR0H,F			;　桁上がり
		movlw	low(voiceN_tbl)		;ｵﾌｾｯﾄに開始ｱﾄﾞﾚｽを加算して
		addwf	FSR0L,F			;　ｴﾝﾄﾘｱﾄﾞﾚｽにする
		movlw	0			;上位桁への
		addwfc	FSR0H,F			;　桁上がり

;音声ﾃﾞｰﾀを取得
		moviw	HDR_VOn_PT_H[FSR0]	;音声ﾃﾞｰﾀのﾜｰﾄﾞｱﾄﾞﾚｽを
		movwf	voice0_ptH		;　取得する
		moviw	HDR_VOn_PT_L[FSR0]
		movwf	voice0_ptL
		lslf	voice0_ptL,F		;ﾊﾞｲﾄｱﾄﾞﾚｽに変える
		rlf	voice0_ptH,F
		moviw	HDR_VOn_LN_H[FSR0]	;音声ﾃﾞｰﾀのﾜｰﾄﾞ数を
		movwf	voice0_zanH		;　取得する
		moviw	HDR_VOn_LN_L[FSR0]
		movwf	voice0_zanL
		moviw	HDR_VOn_PSN[FSR0]	;音声再生のﾌﾟﾘｽｹｰﾙ値を
		movwf	voice0_psn		;　取得する
		movwf	voice0_ps		;ﾌﾟﾘｽｹｰﾗを初期化しておく
		incf	voice0_zanH,F		;decfﾙｰﾌﾟのため
		incf	voice0_zanL,F		; 予め+1しておく

;処理状態を初期化
		bsf	voice0_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得を設定
		btfss	mul_wk,7		;ﾎﾟｯﾌﾟﾉｲｽﾞ対策するときは
		bsf	voice0_no,VO_STS1_BIT	;　ﾗﾝﾌﾟ波形出力を設定
		movfw	api_bsr			;BSRを
		movwf	BSR			;　回復する
		return
#endif


#if VOICE_N>0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声0再生処理
;OUTPUT W:処理結果(0=ﾃﾞｰﾀ有り､1=ﾃﾞｰﾀ終了)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
playback0
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		btfsc	voice0_ptL,0		;上位(後行ﾃﾞｰﾀ)の再生のときは
		goto	playback0_3		;　飛ぶ

;音声ﾃﾞｰﾀの終了ﾁｪｯｸ
		decfsz	voice0_zanL,F		;音声ﾃﾞｰﾀ残があれば
		goto	playback0_1		;　処理を継続する
		decfsz	voice0_zanH,F		;音声ﾃﾞｰﾀ残があれば
		goto	playback0_1		;　処理を継続する
		retlw	1			;｢ﾃﾞｰﾀ終了｣を返す

;音声ﾃﾞｰﾀ読込み
playback0_1	lsrf	voice0_ptH,W		;再生ﾃﾞｰﾀ先頭のﾜｰﾄﾞｱﾄﾞﾚｽ上位を
		banksel	EEADRH			;BANK設定
		movwf	EEADRH			;　EEPｱﾄﾞﾚｽ上位に設定する
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		rrf	voice0_ptL,W		;再生ﾃﾞｰﾀ先頭のﾜｰﾄﾞｱﾄﾞﾚｽ下位を
		banksel	EEADRL			;BANK設定
		movwf	EEADRL			;　EEPｱﾄﾞﾚｽ下位に設定する
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		lslf	EEDATL,F		;再生ﾃﾞｰﾀの
		rlf	EEDATH,W		;　上位7ﾋﾞｯﾄを右詰めで
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		movwf	voice0_data		;　音声再生の後行ﾃﾞｰﾀとする

;下位(先行ﾃﾞｰﾀ)を再生
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;再生ﾃﾞｰﾀの先行ﾃﾞｰﾀを取出す
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		bsf	voice0_ptL,0		;次は下位の再生にする
		goto	playback0_5

;上位(後行ﾃﾞｰﾀ)を再生
playback0_3	lslf	voice0_data,W		;読込み済みの後行ﾃﾞｰﾀを左詰めで取出す

;音声ﾃﾞｰﾀを進める
		incfsz	voice0_ptL,F		;音声ﾃﾞｰﾀを
		decf	voice0_ptH,F		;　次に
		incf	voice0_ptH,F		;　進める

;PWMｽﾃｯﾌﾟ数に変換する
playback0_5	CALLCNV	voice_cnv

;ﾎﾞﾘｭｰﾑ配分を加味する
#if VOICE0_VOL==25
		movwf	voice_out		;1/4をｼﾌﾄ演算で代替する
		lsrf	voice_out,F
		lsrf	voice_out,F
#else
#if VOICE0_VOL==50
		movwf	voice_out		;1/2をｼﾌﾄ演算で代替する
		lsrf	voice_out,F
#else
#if VOICE0_VOL==75
		movwf	voice_out		;3/4をｼﾌﾄ演算で代替する
		lsrf	voice_out,F		;1/2に
		lsrf	voice_out,W		;　1/4を
		addwf	voice_out,F		;　足す
#else
#if VOICE0_VOL==100
		movwf	voice_out		;1/1のままとする
#else
		movwf	mul_b			;出力値(7ﾋﾞｯﾄ左詰め)と
		movlw	PWM_CT*VOICE0_VOL/100	;　音声再生上限値(8ﾋﾞｯﾄ)を
		movwf	mul_a
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積(15ﾋﾞｯﾄ左詰め)の上位8ﾋﾞｯﾄを
		movwf	voice_out		;　音声再生出力値とする
#endif
#endif
#endif
#endif
		retlw	0			;｢ﾃﾞｰﾀ有り｣を返す
#endif


#if VOICE_N>1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声1選択処理(API関数)
;input
;　W(b7):ﾎﾟｯﾌﾟﾉｲｽﾞ抑止(0=する､1=しないで切れ目なく再生する)
;　W(b5-0):音声番号(0=再生中断､1〜63=指定音声番号を再生開始)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声番号を評価
VOICE1_SEL	movwf	mul_wk			;入力ﾊﾟﾗﾒｰﾀを退避しておく
		xorwf	voice1_no,W		;現在再生中の
		andlw	~VO_STS_MSK		;　音声番号と
		btfsc	STATUS,Z		;　同じだったら
		return				;　無効果で戻る
		xorwf	voice1_no,W		;音声番号を
		andlw	~VO_STS_MSK		;　復元する
		btfss	STATUS,Z		;音声番号が
		goto	voice1_sel5		;　0のときは
		clrf	voice1_no		;　制御ﾌﾗｸﾞと音声番号をｸﾘｱする
		return

;音声番号の実装ﾁｪｯｸ
voice1_sel5	addlw	-((voiceN_tbl_end-voiceN_tbl)/HDR_VOn_size+1)
						;音声番号が実装音声数以内で
		btfsc	STATUS,C		;　なかったら
		return				;　無効果で戻る
		addlw	(voiceN_tbl_end-voiceN_tbl)/HDR_VOn_size+1
						;音声番号を復元する
		movwf	voice1_no		;音声番号を記憶しておく

;音声ﾃﾞｰﾀﾍｯﾀﾞを取得
		movfw	BSR			;BSRを
		movwf	api_bsr			;　退避する
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		movlw	high(voiceN_tbl)	;音声ｲﾝﾃﾞｯｸｽｱﾄﾞﾚｽの
		movwf	FSR0H			;　上位桁を設定する
		decf	voice1_no,W		;音声番号-1がｴﾝﾄﾘ番号
		movwf	FSR0L			;ｴﾝﾄﾘ番号*5が
		lslf	FSR0L,F			;　ｲﾝﾃﾞｯｸｽのｵﾌｾｯﾄになる
		lslf	FSR0L,F
		addwf	FSR0L,F
		movlw	0			;上位桁への
		addwfc	FSR0H,F			;　桁上がり
		movlw	low(voiceN_tbl)		;ｵﾌｾｯﾄに開始ｱﾄﾞﾚｽを加算して
		addwf	FSR0L,F			;　ｴﾝﾄﾘｱﾄﾞﾚｽにする
		movlw	0			;上位桁への
		addwfc	FSR0H,F			;　桁上がり

;音声ﾃﾞｰﾀを取得
		moviw	HDR_VOn_PT_H[FSR0]	;音声ﾃﾞｰﾀのﾜｰﾄﾞｱﾄﾞﾚｽを
		movwf	voice1_ptH		;　取得する
		moviw	HDR_VOn_PT_L[FSR0]
		movwf	voice1_ptL
		lslf	voice1_ptL,F		;ﾊﾞｲﾄｱﾄﾞﾚｽに変える
		rlf	voice1_ptH,F
		moviw	HDR_VOn_LN_H[FSR0]	;音声ﾃﾞｰﾀのﾜｰﾄﾞ数を
		movwf	voice1_zanH		;　取得する
		moviw	HDR_VOn_LN_L[FSR0]
		movwf	voice1_zanL
		moviw	HDR_VOn_PSN[FSR0]	;音声再生のﾌﾟﾘｽｹｰﾙ値を
		movwf	voice1_psn		;　取得する
		movwf	voice1_ps		;ﾌﾟﾘｽｹｰﾗを初期化しておく
		incf	voice1_zanH,F		;decfﾙｰﾌﾟのため
		incf	voice1_zanL,F		; 予め+1しておく

;処理状態を初期化
		bsf	voice1_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得を設定
		btfss	mul_wk,7		;ﾎﾟｯﾌﾟﾉｲｽﾞ対策するときは
		bsf	voice1_no,VO_STS1_BIT	;　ﾗﾝﾌﾟ波形出力を設定
		movfw	api_bsr			;BSRを
		movwf	BSR			;　回復する
		return
#endif


#if VOICE_N>1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声1再生処理
;OUTPUT W:処理結果(0=ﾃﾞｰﾀ有り､1=ﾃﾞｰﾀ終了)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
playback1
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		btfsc	voice1_ptL,0		;上位(後行ﾃﾞｰﾀ)の再生のときは
		goto	playback1_3		;　飛ぶ

;音声ﾃﾞｰﾀの終了ﾁｪｯｸ
		decfsz	voice1_zanL,F		;音声ﾃﾞｰﾀ残があれば
		goto	playback1_1		;　処理を継続する
		decfsz	voice1_zanH,F		;音声ﾃﾞｰﾀ残があれば
		goto	playback1_1		;　処理を継続する
		retlw	1			;｢ﾃﾞｰﾀ終了｣を返す

;音声ﾃﾞｰﾀ読込み
playback1_1	lsrf	voice1_ptH,W		;再生ﾃﾞｰﾀ先頭のﾜｰﾄﾞｱﾄﾞﾚｽ上位を
		banksel	EEADRH			;BANK設定
		movwf	EEADRH			;　EEPｱﾄﾞﾚｽ上位に設定する
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		rrf	voice1_ptL,W		;再生ﾃﾞｰﾀ先頭のﾜｰﾄﾞｱﾄﾞﾚｽ下位を
		banksel	EEADRL			;BANK設定
		movwf	EEADRL			;　EEPｱﾄﾞﾚｽ下位に設定する
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		lslf	EEDATL,F		;再生ﾃﾞｰﾀの
		rlf	EEDATH,W		;　上位7ﾋﾞｯﾄを右詰めで
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		movwf	voice1_data		;　音声再生の後行ﾃﾞｰﾀとする

;下位(先行ﾃﾞｰﾀ)を再生
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;再生ﾃﾞｰﾀの先行ﾃﾞｰﾀを取出す
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		bsf	voice1_ptL,0		;次は下位の再生にする
		goto	playback1_5

;上位(後行ﾃﾞｰﾀ)を再生
playback1_3	lslf	voice1_data,W		;読込み済みの後行ﾃﾞｰﾀを左詰めで取出す

;音声ﾃﾞｰﾀを進める
		incfsz	voice1_ptL,F		;音声ﾃﾞｰﾀを
		decf	voice1_ptH,F		;　次に
		incf	voice1_ptH,F		;　進める

;PWMｽﾃｯﾌﾟ数に変換する
playback1_5	CALLCNV	voice_cnv

;ﾎﾞﾘｭｰﾑ配分を加味する
#if VOICE1_VOL==25
		movwf	voice_out		;1/4をｼﾌﾄ演算で代替する
		lsrf	voice_out,F
		lsrf	voice_out,F
#else
#if VOICE1_VOL==50
		movwf	voice_out		;1/2をｼﾌﾄ演算で代替する
		lsrf	voice_out,F
#else
#if VOICE1_VOL==75
		movwf	voice_out		;3/4をｼﾌﾄ演算で代替する
		lsrf	voice_out,F		;1/2に
		lsrf	voice_out,W		;　1/4を
		addwf	voice_out,F		;　足す
#else
#if VOICE1_VOL==100
		movwf	voice_out		;1/1のままとする
#else
		movwf	mul_b			;出力値(7ﾋﾞｯﾄ左詰め)と
		movlw	PWM_CT*VOICE1_VOL/100	;　音声再生上限値(8ﾋﾞｯﾄ)を
		movwf	mul_a
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積(15ﾋﾞｯﾄ左詰め)の上位8ﾋﾞｯﾄを
		movwf	voice_out		;　音声再生出力値とする
#endif
#endif
#endif
#endif
		retlw	0			;｢ﾃﾞｰﾀ有り｣を返す
#endif


#if VOICE_N>2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声2選択処理(API関数)
;input
;　W(b7):ﾎﾟｯﾌﾟﾉｲｽﾞ抑止(0=する､1=しないで切れ目なく再生する)
;　W(b5-0):音声番号(0=再生中断､1〜63=指定音声番号を再生開始)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声番号を評価
VOICE2_SEL	movwf	mul_wk			;入力ﾊﾟﾗﾒｰﾀを退避しておく
		xorwf	voice2_no,W		;現在再生中の
		andlw	~VO_STS_MSK		;　音声番号と
		btfsc	STATUS,Z		;　同じだったら
		return				;　無効果で戻る
		xorwf	voice2_no,W		;音声番号を
		andlw	~VO_STS_MSK		;　復元する
		btfss	STATUS,Z		;音声番号が
		goto	voice2_sel5		;　0のときは
		clrf	voice2_no		;　制御ﾌﾗｸﾞと音声番号をｸﾘｱする
		return

;音声番号の実装ﾁｪｯｸ
voice2_sel5	addlw	-((voiceN_tbl_end-voiceN_tbl)/HDR_VOn_size+1)
						;音声番号が実装音声数以内で
		btfsc	STATUS,C		;　なかったら
		return				;　無効果で戻る
		addlw	(voiceN_tbl_end-voiceN_tbl)/HDR_VOn_size+1
						;音声番号を復元する
		movwf	voice2_no		;音声番号を記憶しておく

;音声ﾃﾞｰﾀﾍｯﾀﾞを取得
		movfw	BSR			;BSRを
		movwf	api_bsr			;　退避する
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		movlw	high(voiceN_tbl)	;音声ｲﾝﾃﾞｯｸｽｱﾄﾞﾚｽの
		movwf	FSR0H			;　上位桁を設定する
		decf	voice2_no,W		;音声番号-1がｴﾝﾄﾘ番号
		movwf	FSR0L			;ｴﾝﾄﾘ番号*5が
		lslf	FSR0L,F			;　ｲﾝﾃﾞｯｸｽのｵﾌｾｯﾄになる
		lslf	FSR0L,F
		addwf	FSR0L,F
		movlw	0			;上位桁への
		addwfc	FSR0H,F			;　桁上がり
		movlw	low(voiceN_tbl)		;ｵﾌｾｯﾄに開始ｱﾄﾞﾚｽを加算して
		addwf	FSR0L,F			;　ｴﾝﾄﾘｱﾄﾞﾚｽにする
		movlw	0			;上位桁への
		addwfc	FSR0H,F			;　桁上がり

;音声ﾃﾞｰﾀを取得
		moviw	HDR_VOn_PT_H[FSR0]	;音声ﾃﾞｰﾀのﾜｰﾄﾞｱﾄﾞﾚｽを
		movwf	voice2_ptH		;　取得する
		moviw	HDR_VOn_PT_L[FSR0]
		movwf	voice2_ptL
		lslf	voice2_ptL,F		;ﾊﾞｲﾄｱﾄﾞﾚｽに変える
		rlf	voice2_ptH,F
		moviw	HDR_VOn_LN_H[FSR0]	;音声ﾃﾞｰﾀのﾜｰﾄﾞ数を
		movwf	voice2_zanH		;　取得する
		moviw	HDR_VOn_LN_L[FSR0]
		movwf	voice2_zanL
		moviw	HDR_VOn_PSN[FSR0]	;音声再生のﾌﾟﾘｽｹｰﾙ値を
		movwf	voice2_psn		;　取得する
		movwf	voice2_ps		;ﾌﾟﾘｽｹｰﾗを初期化しておく
		incf	voice2_zanH,F		;decfﾙｰﾌﾟのため
		incf	voice2_zanL,F		; 予め+1しておく

;処理状態を初期化
		bsf	voice2_no,VO_STS0_BIT	;最初のﾃﾞｰﾀ取得を設定
		btfss	mul_wk,7		;ﾎﾟｯﾌﾟﾉｲｽﾞ対策するときは
		bsf	voice2_no,VO_STS1_BIT	;　ﾗﾝﾌﾟ波形出力を設定
		movfw	api_bsr			;BSRを
		movwf	BSR			;　回復する
		return
#endif


#if VOICE_N>2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;音声2再生処理
;OUTPUT W:処理結果(0=ﾃﾞｰﾀ有り､1=ﾃﾞｰﾀ終了)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
playback2
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		btfsc	voice2_ptL,0		;上位(後行ﾃﾞｰﾀ)の再生のときは
		goto	playback2_3		;　飛ぶ

;音声ﾃﾞｰﾀの終了ﾁｪｯｸ
		decfsz	voice2_zanL,F		;音声ﾃﾞｰﾀ残があれば
		goto	playback2_1		;　処理を継続する
		decfsz	voice2_zanH,F		;音声ﾃﾞｰﾀ残があれば
		goto	playback2_1		;　処理を継続する
		retlw	1			;｢ﾃﾞｰﾀ終了｣を返す

;音声ﾃﾞｰﾀ読込み
playback2_1	lsrf	voice2_ptH,W		;再生ﾃﾞｰﾀ先頭のﾜｰﾄﾞｱﾄﾞﾚｽ上位を
		banksel	EEADRH			;BANK設定
		movwf	EEADRH			;　EEPｱﾄﾞﾚｽ上位に設定する
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		rrf	voice2_ptL,W		;再生ﾃﾞｰﾀ先頭のﾜｰﾄﾞｱﾄﾞﾚｽ下位を
		banksel	EEADRL			;BANK設定
		movwf	EEADRL			;　EEPｱﾄﾞﾚｽ下位に設定する
		bcf	EECON1,EECFGS		;Config領域ではない
		bsf	EECON1,EEPGD		;Program領域をｱｸｾｽ
		bsf	EECON1,RD		;読込み実行
		nop
		nop
		lslf	EEDATL,F		;再生ﾃﾞｰﾀの
		rlf	EEDATH,W		;　上位7ﾋﾞｯﾄを右詰めで
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		movwf	voice2_data		;　音声再生の後行ﾃﾞｰﾀとする

;下位(先行ﾃﾞｰﾀ)を再生
		banksel	EEDATL			;BANK設定
		movfw	EEDATL			;再生ﾃﾞｰﾀの先行ﾃﾞｰﾀを取出す
		banksel	VOICE_BANK		;音声再生ﾃﾞｰﾀのBANK設定
		bsf	voice2_ptL,0		;次は下位の再生にする
		goto	playback2_5

;上位(後行ﾃﾞｰﾀ)を再生
playback2_3	lslf	voice2_data,W		;読込み済みの後行ﾃﾞｰﾀを左詰めで取出す

;音声ﾃﾞｰﾀを進める
		incfsz	voice2_ptL,F		;音声ﾃﾞｰﾀを
		decf	voice2_ptH,F		;　次に
		incf	voice2_ptH,F		;　進める

;PWMｽﾃｯﾌﾟ数に変換する
playback2_5	CALLCNV	voice_cnv

;ﾎﾞﾘｭｰﾑ配分を加味する
#if VOICE2_VOL==25
		movwf	voice_out		;1/4をｼﾌﾄ演算で代替する
		lsrf	voice_out,F
		lsrf	voice_out,F
#else
#if VOICE2_VOL==50
		movwf	voice_out		;1/2をｼﾌﾄ演算で代替する
		lsrf	voice_out,F
#else
#if VOICE2_VOL==75
		movwf	voice_out		;3/4をｼﾌﾄ演算で代替する
		lsrf	voice_out,F		;1/2に
		lsrf	voice_out,W		;　1/4を
		addwf	voice_out,F		;　足す
#else
#if VOICE2_VOL==100
		movwf	voice_out		;1/1のままとする
#else
		movwf	mul_b			;出力値(7ﾋﾞｯﾄ左詰め)と
		movlw	PWM_CT*VOICE0_VOL/100	;　音声再生上限値(8ﾋﾞｯﾄ)を
		movwf	mul_a
		call	mul7_exe		;　積算して
		movfw	mul_cH			;　積(15ﾋﾞｯﾄ左詰め)の上位8ﾋﾞｯﾄを
		movwf	voice_out		;　音声再生出力値とする
#endif
#endif
#endif
#endif
		retlw	0			;｢ﾃﾞｰﾀ有り｣を返す
#endif


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;8ﾋﾞｯﾄ×8ﾋﾞｯﾄまたは8ﾋﾞｯﾄ×7ﾋﾞｯﾄの乗算処理(逐次処理方式)
;input mul_a:8ﾋﾞｯﾄ乗数(処理後にﾃﾞｰﾀは破壊される)
;      mul_b:8ﾋﾞｯﾄまたは7ﾋﾞｯﾄ乗数(処理後にﾃﾞｰﾀは破壊される､7ﾋﾞｯﾄの場合は右詰め)
;output mul_cH:積の上位､mul_cL:積の下位(mul_bが7ﾋﾞｯﾄの場合は積15ﾋﾞｯﾄは左詰め)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
mul8_exe	movlw	8			;mul_bが8ﾋﾞｯﾄの場合のｴﾝﾄﾘ
		goto	mul2
mul7_exe	movlw	7			;mul_bが7ﾋﾞｯﾄの場合のｴﾝﾄﾘ
mul2		movwf	mul_wk			;乗数bのﾋﾞｯﾄ数を繰返し回数とする
		clrf	mul_cH			;積をｸﾘｱしておく
		clrf	mul_cL
mul5		movfw	mul_a			;乗数aをﾛｰﾄﾞ
		bcf	STATUS,C		;仮にｷｬﾘｰ無しにしておく
		btfss	mul_b,0			;乗数bの最下位ﾋﾞｯﾄが0のときは
		goto	mul8			;　飛ぶ
		addwf	mul_cH,F		;積に乗数aを加算して
mul8		rrf	mul_cH,F		;　ｷｬﾘｰ付きでｼﾌﾄする
		rrf	mul_cL,F
		lsrf	mul_b,F			;乗数bをｼﾌﾄする
		decfsz	mul_wk,F		;乗数bのﾋﾞｯﾄ数だけ
		goto	mul5			;　繰り返す
		return


#if CNV_PAGE>0
		org	CNV_PAGE
#endif



